# Code Duplication Analysis

This document outlines the process for detecting and managing code duplication within the Prompt Manager project using `jscpd`. Regularly checking for and addressing unnecessary code duplication helps maintain code quality, reduce bugs, and improve maintainability.

## Why Track Code Duplication?

-   **Maintainability:** Changes to duplicated code must be made in multiple places, increasing the risk of inconsistency and bugs.
-   **Readability:** Large amounts of duplicated code can make the codebase harder to understand.
-   **Testability:** Duplicated logic might require duplicated test efforts.
-   **Bug Proneness:** Fixing a bug in one copy of duplicated code might leave other copies unfixed.

While some duplication is acceptable or even necessary (e.g., boilerplate in generated files, specific test setups), minimizing unintentional duplication is a good practice.

## Running `jscpd`

The project's `Makefile` provides the primary command for running `jscpd` and generating reports.

### Generating Reports (Console and HTML)

To check for code duplication and generate both a console text summary and a detailed HTML report, run:

```bash
make lint-cpd
```

This command will:
- Print a text-based report directly to your console.
- Generate an HTML report in the `logs/jscpd-report/html/` directory. Open the `index.html` file in that directory in your web browser to explore the duplicated code blocks.

(The underlying command used by the Makefile is `npx jscpd --reporters=html,console --output=./logs/jscpd-report --ignore "**/.venv/**,**/venv/**,**/node_modules/**,**/.mypy_cache/**,**/.pytest_cache/**,**/.ruff_cache/**,**/archive/**,**/*.lock,**/data/**,**/logs/**,**/dist/**,**/build/**,**/cov_html/**,**/tests/**" .` for reference.)

Note: The `tests/` directory is excluded from this scan, as test code often contains legitimate similarities for scaffolding and setup that are not indicative of problematic duplication in the application code.

## Interpreting Results

When reviewing the `jscpd` report:

-   **Percentage:** Pay attention to the overall percentage of duplicated code.
-   **Number of Clones:** Note the total number of duplicated blocks.
-   **Lines and Tokens:** Larger blocks (more lines/tokens) are generally more critical to address.
-   **File Locations:** Identify patterns where duplication occurs most frequently (e.g., specific modules, test files, UI components).

## Whitelist of Acceptable Duplication

Not all duplication needs to be eliminated. Some instances might be acceptable due to various reasons. This section serves as a record of duplications that have been reviewed and are considered acceptable.

**(Please review the HTML report generated by `jscpd` and list any intentionally kept duplications here, along with a brief justification.)**

*   **`src/static/js/visualization/task_visualizer.js`**
    *   **Clone 1 & 2:** Lines `20:5 - 27:4` (constructor) vs `361:5 - 368:4` (constructor), and `45:2 - 61:27` (initialize) vs `385:2 - 401:17` (initialize) between `TaskGraphVisualizer` and `TaskTimelineVisualizer`.
        *   **Justification:** While the constructors and `initialize` methods for `TaskGraphVisualizer` and `TaskTimelineVisualizer` share a common structure (setting options, creating an SVG container), the specific options initialized and the D3.js components set up (force layout vs. time scales/axes) are distinct to each visualizer type. Refactoring into a shared base class or utility would likely introduce more complexity than benefit for these standard D3 initialization patterns.
    *   **Clone 3:** Lines `319:13 - 334:4` (resize) vs `592:13 - 607:4` (resize) between `TaskGraphVisualizer` and `TaskTimelineVisualizer`.
        *   **Justification:** Both `resize` methods update dimensions and trigger a re-render. However, the specific D3 update logic (`simulation.force('center')` for graph vs. updating scales and calling `updateVisualization()` for timeline) is unique to each visualizer. A shared method would require knowledge of these internal differences, negating much of the benefit.

**Example Categories for Whitelisting:**

*   **Test Scaffolding:** Similar setup or teardown logic in multiple test files where abstraction adds more complexity than benefit.
    *   *Example Entry:* `tests/unit/test_feature_x.py` and `tests/unit/test_feature_y.py`: Similar `asyncSetUp` method structure for creating mock objects. (Justification: Minor variations, and abstraction would obscure test clarity).
*   **API Model Definitions:** Pydantic models for request/response that are structurally identical but represent different semantic entities (and cannot be easily shared or aliased without confusion).
    *   *Example Entry:* `src/models/request_a.py` and `src/models/request_b.py`: Identical fields but used for distinct API endpoints with different future evolution paths.
*   **HTML/UI Snippets:** Small, repeated HTML structures where creating a macro/component is overkill or makes the template harder to follow.
    *   *Example Entry:* `src/templates/page1.html` and `src/templates/page2.html`: Duplication of a simple 2-line alert box structure. (Justification: Trivial, and templating engine includes are not desired for this small snippet).
*   **Configuration Boilerplate:** Sections of configuration files (e.g., CI workflows) that are necessarily repeated.

---

Please update the whitelist above as you review the `jscpd` report. 
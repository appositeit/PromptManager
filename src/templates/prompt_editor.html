{% extends "base.html" %}

{% block title %}Prompt Editor{% endblock %}

{% block extra_js_head %}
<script src="/static/js/utils.js"></script>
{% endblock %}

{% block header_title %}{{ prompt_id }}{% endblock %}

{% block header_actions %}
<div class="btn-group me-2">
    <a href="/manage/prompts" class="btn btn-outline-secondary" id="back-btn" title="Back to Prompt List (Alt+B)">
        <i class="bi bi-arrow-left"></i> Back to List
    </a>
</div>
<div class="btn-group">
    <button id="copy-btn" class="btn btn-outline-primary" title="Copy content to clipboard (Alt+C)">
        <i class="bi bi-clipboard"></i> Copy
    </button>
    <button id="toggle-view-btn" class="btn btn-outline-primary" title="Toggle between raw and expanded view (Alt+T)">
        <i class="bi bi-eye"></i> Toggle View
    </button>
    <button id="search-replace-btn" class="btn btn-outline-primary" title="Search and Replace (Alt+R)">
        <i class="bi bi-search"></i> Search/Replace
    </button>
    <button id="save-btn" class="btn btn-outline-success" title="Save changes (Alt+S)">
        <i class="bi bi-save"></i> Save
    </button>
    <button id="delete-btn" class="btn btn-outline-danger" title="Delete this prompt">
        <i class="bi bi-trash"></i> Delete
    </button>
</div>
{% endblock %}

{% block content %}
<!-- Hidden element to store prompt ID for JavaScript -->
<span id="prompt-id" class="d-none">{{ prompt_id }}</span>

<div class="container-fluid">
    <div class="row">
        <!-- Main editor column - takes up more space -->
        <div class="col-md-9">
            <div class="card">
                <div class="card-body">
                    <div class="editor-container">
                        <div id="editor-tabs" class="nav nav-tabs">
                            <button class="nav-link active" id="raw-tab" data-bs-toggle="tab" data-bs-target="#raw-content" title="View and edit original content with inclusion references">Raw Content</button>
                            <button class="nav-link" id="expanded-tab" data-bs-toggle="tab" data-bs-target="#expanded-content" title="View content with all inclusions expanded">Expanded Content</button>
                        </div>
                        
                        <div class="tab-content">
                            <div class="tab-pane fade show active" id="raw-content">
                                <div id="editor"></div>
                            </div>
                            <div class="tab-pane fade" id="expanded-content">
                                <div id="preview" class="markdown-preview"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Warnings card remains below the editor -->
            <div class="row mt-3">
                <div class="col-12">
                    <div class="card" id="warnings-card" style="display: none;">
                        <div class="card-header bg-warning text-dark">
                            <h5 class="card-title mb-0">
                                <i class="bi bi-exclamation-triangle-fill me-2"></i>
                                Warnings
                            </h5>
                        </div>
                        <div class="card-body">
                            <div id="warnings">
                                <!-- Warnings will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Sidebar with metadata and references - takes up less space -->
        <div class="col-md-3">
            <!-- Description and Tags card -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5 class="card-title mb-0">Metadata</h5>
                </div>
                <div class="card-body">
                    <div class="mb-2">
                        <div class="d-flex align-items-center">
                            <span class="badge rounded-pill me-2" id="prompt-type-badge">Standard</span>
                            <span class="ms-auto small text-muted">Last updated: <span id="last-updated">-</span></span>
                        </div>
                    </div>
                    <div class="mb-2">
                        <span class="small text-muted">Directory: <span id="prompt-directory" class="fw-semibold">-</span></span>
                    </div>
                    <div class="mb-3">
                        <label for="prompt-description" class="form-label">Description</label>
                        <input type="text" class="form-control form-control-sm" id="prompt-description">
                    </div>
                    <div class="mb-3">
                        <label for="prompt-tags" class="form-label">Tags</label>
                        <input type="text" class="form-control form-control-sm" id="prompt-tags" placeholder="tag1, tag2, tag3">
                    </div>
                </div>
            </div>
            
            <!-- Dependencies card -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5 class="card-title mb-0">Dependencies</h5>
                </div>
                <div class="card-body">
                    <div id="dependencies">
                        <p class="text-muted">No dependencies found.</p>
                    </div>
                </div>
            </div>
            
            <!-- Referenced By card -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5 class="card-title mb-0">Referenced By</h5>
                </div>
                <div class="card-body">
                    <div id="referenced-by">
                        <p class="text-muted">Loading references...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Delete Prompt Confirmation Modal -->
<div class="modal fade" id="deletePromptModal" tabindex="-1" aria-labelledby="deletePromptModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deletePromptModalLabel">Confirm Deletion</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this prompt?</p>
                <p class="text-danger">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirm-delete-btn">Delete</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
    /* Make the editor take up maximum vertical space */
    #editor, #preview {
        height: calc(85vh - 90px);
        min-height: 600px;
    }
    
    .CodeMirror {
        height: 100%;
        font-size: 14px;
        line-height: 1.6;
    }
    
    /* Style the tabs */
    #editor-tabs .nav-link {
        font-size: 0.9rem;
        padding: 0.5rem 1rem;
    }
    
    /* Fix for expanded content view overflow issue */
    #expanded-content {
        background-color: #fff;
    }
    
    #preview {
        background-color: #fff;
        height: auto;
        min-height: 600px;
        padding: 15px;
        width: 100%;
        overflow-x: hidden;
        border: 1px solid #dee2e6;
        border-radius: 4px;
    }
    
    /* Make metadata elements smaller and more compact */
    .form-control-sm {
        height: 30px;
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
    }
    
    .card-header {
        padding: 0.5rem 1rem;
    }
    
    .small {
        font-size: 0.875rem;
    }
    
    /* Style the sidebar cards to be more compact */
    .col-md-3 .card {
        font-size: 0.9rem;
    }
    
    .col-md-3 .card-body {
        padding: 0.75rem;
    }
    
    .col-md-3 .form-label {
        margin-bottom: 0.25rem;
        font-weight: 500;
    }
    
    /* Make the list groups in sidebar more compact */
    .col-md-3 .list-group-item {
        padding: 0.5rem 0.75rem;
    }
    
    /* Sticky sidebar */
    @media (min-width: 768px) {
        .col-md-3 {
            position: sticky;
            top: 0;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
    }
</style>
{% endblock %}

{% block extra_js %}
<script src="/static/js/search-replace.js"></script>
<script>
    // Import utility functions
    // Use the showToast function from utils.js
    
    // Convert markdown to HTML
    function markdownToHtml(markdown) {
        if (!markdown) return '';
        
        // Simple markdown to HTML conversion
        return markdown
            .replace(/\n\n/g, '<br><br>')
            .replace(/\n/g, '<br>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/```([a-z]*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>')
            .replace(/`([^`]+)`/g, '<code>$1</code>')
            .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
            .replace(/^# (.*?)$/gm, '<h1>$1</h1>')
            .replace(/^## (.*?)$/gm, '<h2>$1</h2>')
            .replace(/^### (.*?)$/gm, '<h3>$1</h3>')
            .replace(/^#### (.*?)$/gm, '<h4>$1</h4>')
            .replace(/^##### (.*?)$/gm, '<h5>$1</h5>')
            .replace(/^###### (.*?)$/gm, '<h6>$1</h6>');
    }
    
    // Format date function
    function formatDate(dateString) {
        
        if (!dateString) return 'Unknown';
        try {
            // Try using dayjs if available
            if (window.dayjs) {
                return dayjs(dateString).format('YYYY-MM-DD HH:mm:ss');
            }
            // Fallback to native Date
            const date = new Date(dateString);
            return date.toLocaleString();
        } catch (error) {
            console.error('Error formatting date:', error);
            return dateString;
        }
    }
    
    // Global variables
    let editor;
    let promptId = "{{ prompt_id }}";
    let promptData = null;
    let socket = null;
    let expandedContent = "";
    let dependencies = [];
    let saveTimeout = null;
    let isComposite = false;
    let allPrompts = []; // Store all available prompts for autocomplete
    let searchReplace = null; // Search and replace functionality
    
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize CodeMirror editor
        editor = CodeMirror(document.getElementById('editor'), {
            mode: 'markdown',
            theme: 'default',
            lineNumbers: true,
            lineWrapping: true,
            autofocus: true,
            extraKeys: {
                "Tab": function(cm) {
                    // If autocomplete is active, accept selection
                    if (cm.state.completionActive) {
                        cm.state.completionActive.pick();
                        return;
                    }
                    // Otherwise, insert a tab
                    cm.replaceSelection("    ");
                },
                "Ctrl-Space": function(cm) {
                    cm.showHint({ hint: promptHint });
                },
                "Alt-T": function(cm) {
                    toggleView();
                },
                "Alt-R": function(cm) {
                    if (searchReplace && document.getElementById('raw-tab').classList.contains('active')) {
                        searchReplace.showDialog();
                    }
                }
            }
        });
        
        // Initialize search and replace functionality
        searchReplace = new SearchReplace(editor);
        
        // Setup the custom hint function
        setupPromptCompletion();
        
        // Setup global keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Alt+B for back
            if (e.altKey && e.key === 'b') {
                e.preventDefault();
                window.location.href = '/manage/prompts';
            }
            
            // Alt+T for toggle view (handled in CodeMirror for when editor has focus)
            if (e.altKey && e.key === 't' && !editor.hasFocus()) {
                e.preventDefault();
                toggleView();
            }
            
            // Alt+C for copy content
            if (e.altKey && e.key === 'c') {
                e.preventDefault();
                copyPromptContent();
            }
            
            // Alt+S for save
            if (e.altKey && e.key === 's') {
                e.preventDefault();
                document.getElementById('save-btn').click();
            }
        });
        
        // Load prompt data
        loadPromptData();
        
        // Set up WebSocket connection for real-time editing
        setupWebSocket();
        
        // Set up event handlers
        editor.on('change', handleEditorChange);
        
        document.getElementById('prompt-description').addEventListener('input', handleMetadataChange);
        document.getElementById('prompt-tags').addEventListener('input', handleMetadataChange);
        
        document.getElementById('copy-btn').addEventListener('click', copyPromptContent);
        document.getElementById('toggle-view-btn').addEventListener('click', toggleView);
        document.getElementById('search-replace-btn').addEventListener('click', function() {
            if (searchReplace && document.getElementById('raw-tab').classList.contains('active')) {
                searchReplace.showDialog();
            } else if (!document.getElementById('raw-tab').classList.contains('active')) {
                // If not in raw tab, switch to it first
                document.getElementById('raw-tab').click();
                setTimeout(() => {
                    if (searchReplace) searchReplace.showDialog();
                }, 100);
            }
        });
        document.getElementById('save-btn').addEventListener('click', function() {
            const content = editor.getValue();
            saveViaApi(content);
            
            const description = document.getElementById('prompt-description').value;
            const tagsStr = document.getElementById('prompt-tags').value;
            const tags = tagsStr.split(',').map(tag => tag.trim()).filter(tag => tag);
            saveMetadataViaApi(description, tags);
        });
        document.getElementById('delete-btn').addEventListener('click', showDeleteConfirmation);
        document.getElementById('confirm-delete-btn').addEventListener('click', deletePrompt);
        
        // Handle tab changes
        document.getElementById('expanded-tab').addEventListener('click', function() {
            // Set background to white for extended content
            document.getElementById('expanded-content').style.backgroundColor = '#ffffff';
            updateExpandedView();
        });
    });
    
    function loadPromptData() {
        fetch(`/api/prompts/${promptId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Prompt not found');
                }
                return response.json();
            })
            .then(data => {
                promptData = data;
                
                // Set editor content
                editor.setValue(data.content);
                
                // Set metadata fields
                document.getElementById('prompt-description').value = data.description || '';
                document.getElementById('prompt-tags').value = data.tags.join(', ');
                document.getElementById('last-updated').textContent = formatDate(data.updated_at);
                document.getElementById('prompt-directory').textContent = data.directory || 'Not specified';
                
                // Set prompt type badge
                const badge = document.getElementById('prompt-type-badge');
                badge.textContent = data.prompt_type.charAt(0).toUpperCase() + data.prompt_type.slice(1);
                
                // Set badge color based on type
                if (data.prompt_type === 'composite') {
                    badge.classList.add('bg-success');
                    isComposite = true;
                } else if (data.prompt_type === 'system') {
                    badge.classList.add('bg-primary');
                } else if (data.prompt_type === 'user') {
                    badge.classList.add('bg-info');
                } else {
                    badge.classList.add('bg-secondary');
                }
                
                // If it's a composite prompt, update the expanded view
                if (isComposite) {
                    updateExpandedView();
                }
                
                // Find references to this prompt
                loadReferences();
            })
            .catch(error => {
                console.error('Error loading prompt:', error);
                showToast('Error loading prompt: ' + error.message, 'danger');
            });
    }
    
    function setupWebSocket() {
        try {
            // Create WebSocket connection
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/api/prompts/ws/${promptId}`;
            console.log(`Connecting to WebSocket at: ${wsUrl}`);
            socket = new WebSocket(wsUrl);
        
        // Connection opened
        socket.addEventListener('open', function(event) {
            console.log('WebSocket connection established successfully');
            
            // Request all prompts to build autocomplete list once connected
            loadAllPrompts();
            
            // Send a test message to confirm connection is working
            console.log('Sending test expand message to WebSocket');
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    action: 'expand',
                    content: editor.getValue(),
                    prompt_id: promptId
                }));
            }
        });
        
        // Listen for messages
        socket.addEventListener('message', function(event) {
            console.log('WebSocket message received:', event.data);
            try {
                const data = JSON.parse(event.data);
                
                switch (data.action) {
                    case 'initial':
                        // Initial content already loaded via API
                        console.log('Received initial content');
                        break;
                        
                    case 'update_status':
                        if (data.success) {
                            const lastUpdatedEl = document.getElementById('last-updated');
                            if (lastUpdatedEl) {
                                lastUpdatedEl.textContent = formatDate(data.timestamp);
                            }
                            showToast('Prompt saved', 'success');
                        } else {
                            showToast('Error saving prompt', 'danger');
                        }
                        break;
                        
                    case 'expanded':
                        console.log('Received expanded content:', data);
                        // Store expanded content for preview only - never modify the raw content
                        expandedContent = data.expanded || data.content || '';
                        dependencies = data.dependencies || [];
                        
                        // Update preview only if we're on the expanded tab
                        if (document.getElementById('expanded-tab').classList.contains('active') || 
                            document.getElementById('expanded-content').classList.contains('show', 'active')) {
                            try {
                                console.log('Updating preview with expanded content');
                                document.getElementById('preview').innerHTML = markdownToHtml(expandedContent);
                                
                                // Force the preview container to extend its height
                                const previewElement = document.getElementById('preview');
                                const contentHeight = previewElement.scrollHeight;
                                if (contentHeight > 600) {
                                    previewElement.style.height = contentHeight + 'px';
                                }
                            } catch (error) {
                                console.error('Error rendering expanded content:', error);
                                document.getElementById('preview').innerHTML = '<div class="alert alert-danger">Error rendering expanded content. See console for details.</div>';
                            }
                        }
                        
                        // Update dependencies list
                        updateDependenciesList();
                        
                        // Show warnings if any
                        if (data.warnings && data.warnings.length > 0) {
                            showWarnings(data.warnings);
                        } else {
                            hideWarnings();
                        }
                        break;
                        
                    default:
                        console.log('Unknown action received:', data.action);
                }
            } catch (error) {
                console.error('Error processing WebSocket message:', error);
            }
        });
        
        // Connection closed
        socket.addEventListener('close', function(event) {
            console.log(`WebSocket connection closed with code ${event.code}, reason: ${event.reason}`);
            
            // Try to reconnect after a delay
            setTimeout(() => {
                console.log('Attempting to reconnect...');
                setupWebSocket();
            }, 2000);
        });
        
        // Connection error
        socket.addEventListener('error', function(event) {
            console.error('WebSocket error:', event);
            console.error('Error details:', JSON.stringify(event, Object.getOwnPropertyNames(event)));
            showToast('WebSocket connection error. Falling back to API.', 'warning');
            
            // Force immediate use of API fallback
            if (document.getElementById('expanded-tab').classList.contains('active') || 
                document.getElementById('expanded-content').classList.contains('show', 'active')) {
                useFallbackApi();
            }
        });
        } catch (error) {
            console.error('Error setting up WebSocket:', error);
            showToast('WebSocket setup error: ' + error.message, 'danger');
        }
    }
    
    // Function to use the API fallback for expansion
    function useFallbackApi() {
        const content = editor.getValue();
        console.log('Using API fallback with content:', content);
        
        fetch('/api/prompts/expand', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: content,
                prompt_id: promptId
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Expansion API response:', data);
            expandedContent = data.expanded || data.content;
            dependencies = data.dependencies || [];
            
            // Update preview
            try {
                console.log('Updating preview with expanded content from API');
                document.getElementById('preview').innerHTML = markdownToHtml(expandedContent);
                
                // Force the preview container to extend its height
                const previewElement = document.getElementById('preview');
                const contentHeight = previewElement.scrollHeight;
                if (contentHeight > 600) {
                    previewElement.style.height = contentHeight + 'px';
                }
            } catch (error) {
                console.error('Error rendering expanded content:', error);
                document.getElementById('preview').innerHTML = '<div class="alert alert-danger">Error rendering expanded content. See console for details.</div>';
            }
            
            // Update dependencies list
            updateDependenciesList();
            
            // Show warnings if any
            if (data.warnings && data.warnings.length > 0) {
                showWarnings(data.warnings);
            } else {
                hideWarnings();
            }
        })
        .catch(error => {
            console.error('Error with API fallback:', error);
            showToast('Error expanding content: ' + error.message, 'danger');
            document.getElementById('preview').innerHTML = '<div class="alert alert-danger">Error expanding content. API fallback failed.</div>';
        });
    }
    
    function handleEditorChange() {
        // Clear previous timeout
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
        
        // Set new timeout for autosave (debounce)
        saveTimeout = setTimeout(() => {
            const content = editor.getValue();
            
            // Try to send update via WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                try {
                    socket.send(JSON.stringify({
                        action: 'update',
                        content: content
                    }));
                    
                    // If this is a composite prompt or if the content contains inclusion markers,
                    // also request expansion for preview purposes
                    if (isComposite || content.includes('[[')) {
                        socket.send(JSON.stringify({
                            action: 'expand',
                            content: content,
                            prompt_id: promptId
                        }));
                    }
                } catch (error) {
                    console.error('Error sending WebSocket message for save:', error);
                    // Fall back to API save
                    saveViaApi(content);
                }
            } else {
                // WebSocket not available, use API fallback
                console.log('WebSocket not available for save, using API fallback');
                saveViaApi(content);
            }
        }, 1000); // 1 second debounce
    }
    
    // Function to save via API when WebSocket is not available
    function saveViaApi(content) {
        showToast('Saving via API...', 'info');
        
        fetch(`/api/prompts/${promptId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: content
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Save API response:', data);
            showToast('Prompt saved', 'success');
            
            // Update last updated timestamp if available
            if (data.updated_at) {
                const lastUpdatedEl = document.getElementById('last-updated');
                if (lastUpdatedEl) {
                    lastUpdatedEl.textContent = formatDate(data.updated_at);
                }
            }
            
            // If this is a composite prompt, update the expanded view
            if (isComposite || content.includes('[[')) {
                if (document.getElementById('expanded-tab').classList.contains('active') || 
                    document.getElementById('expanded-content').classList.contains('show', 'active')) {
                    useFallbackApi();
                }
            }
        })
        .catch(error => {
            console.error('Error saving via API:', error);
            showToast('Error saving prompt: ' + error.message, 'danger');
        });
    }
    
    function handleMetadataChange() {
        // Clear previous timeout
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
        
        // Set new timeout for autosave (debounce)
        saveTimeout = setTimeout(() => {
            const description = document.getElementById('prompt-description').value;
            const tagsStr = document.getElementById('prompt-tags').value;
            const tags = tagsStr.split(',').map(tag => tag.trim()).filter(tag => tag);
            
            // Try to send update via WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                try {
                    socket.send(JSON.stringify({
                        action: 'update_metadata',
                        description: description,
                        tags: tags
                    }));
                } catch (error) {
                    console.error('Error sending WebSocket message for metadata:', error);
                    // Fall back to API save
                    saveMetadataViaApi(description, tags);
                }
            } else {
                // WebSocket not available, use API fallback
                console.log('WebSocket not available for metadata save, using API fallback');
                saveMetadataViaApi(description, tags);
            }
        }, 1000); // 1 second debounce
    }
    
    // Function to save metadata via API when WebSocket is not available
    function saveMetadataViaApi(description, tags) {
        showToast('Saving metadata via API...', 'info');
        
        fetch(`/api/prompts/${promptId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                description: description,
                tags: tags
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Save metadata API response:', data);
            showToast('Metadata saved', 'success');
            
            // Update last updated timestamp if available
            if (data.updated_at) {
                const lastUpdatedEl = document.getElementById('last-updated');
                if (lastUpdatedEl) {
                    lastUpdatedEl.textContent = formatDate(data.updated_at);
                }
            }
        })
        .catch(error => {
            console.error('Error saving metadata via API:', error);
            showToast('Error saving metadata: ' + error.message, 'danger');
        });
    }
    
    function updateExpandedView() {
        console.log('Updating expanded view');
        
        // Get current content
        const content = editor.getValue();
        console.log('Current editor content:', content);
        
        // Ensure the expanded content tab has white background extending fully
        const expandedContent = document.getElementById('expanded-content');
        expandedContent.style.backgroundColor = '#ffffff';
        
        // Send expansion request via WebSocket
        if (socket && socket.readyState === WebSocket.OPEN) {
            try {
                console.log('Sending expansion request via WebSocket');
                socket.send(JSON.stringify({
                    action: 'expand',
                    content: content,
                    prompt_id: promptId
                }));
            } catch (error) {
                console.error('Error sending WebSocket message:', error);
                useFallbackApi(); // Use API fallback on WebSocket error
            }
        } else {
            console.log('WebSocket not available, using API fallback');
            // Fallback to API if WebSocket is not available
            showToast('Using API fallback for expansion', 'info');
            useFallbackApi();
        }
    }
    
    function updateDependenciesList() {
        const dependenciesContainer = document.getElementById('dependencies');
        
        if (dependencies.length === 0) {
            dependenciesContainer.innerHTML = '<p class="text-muted">No dependencies found.</p>';
            return;
        }
        
        let html = '<ul class="list-group list-group-flush">';
        
        dependencies.forEach(dep => {
            html += `
                <li class="list-group-item py-1 px-2">
                    <a href="/prompts/${dep}">${dep}</a>
                </li>
            `;
        });
        
        html += '</ul>';
        
        dependenciesContainer.innerHTML = html;
    }
    
    function loadReferences() {
        // Find all prompts that reference this one
        fetch('/api/prompts/all')
            .then(response => response.json())
            .then(prompts => {
                // Filter prompts that might reference this one
                const references = prompts.filter(p => 
                    p.prompt_type === 'composite' && 
                    p.content.includes(`[[${promptId}]]`) ||
                    p.content.includes(`[[${promptId}.md]]`)
                );
                
                const referencedByContainer = document.getElementById('referenced-by');
                
                if (references.length === 0) {
                    referencedByContainer.innerHTML = '<p class="text-muted">No references found.</p>';
                    return;
                }
                
                let html = '<ul class="list-group list-group-flush">';
                
                references.forEach(ref => {
                    html += `
                        <li class="list-group-item py-1 px-2">
                            <div>
                                <a href="/prompts/${ref.id}">${ref.id}</a>
                                ${ref.description ? `<small class="text-muted d-block">${ref.description}</small>` : ''}
                            </div>
                            <span class="badge bg-${ref.prompt_type === 'composite' ? 'success' : 'secondary'} rounded-pill">
                                ${ref.prompt_type}
                            </span>
                        </li>
                    `;
                });
                
                html += '</ul>';
                
                referencedByContainer.innerHTML = html;
            })
            .catch(error => {
                console.error('Error loading references:', error);
                document.getElementById('referenced-by').innerHTML = '<p class="text-danger">Error loading references.</p>';
            });
    }
    
    function copyPromptContent() {
        // Determine which content to copy based on current view
        const content = document.getElementById('expanded-content').classList.contains('active') 
            ? expandedContent 
            : editor.getValue();
            
        // Copy to clipboard
        navigator.clipboard.writeText(content)
            .then(() => {
                showToast('Copied to clipboard');
            })
            .catch(error => {
                console.error('Error copying to clipboard:', error);
                showToast('Error copying to clipboard', 'danger');
                
                // Fallback method for browsers that don't support clipboard API
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = content;
                    textarea.style.position = 'fixed';  // Avoid scrolling to bottom
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showToast('Copied to clipboard (fallback method)');
                } catch (fallbackError) {
                    console.error('Fallback copy failed:', fallbackError);
                    showToast('Could not copy to clipboard', 'danger');
                }
            });
    }
    
    function toggleView() {
        // Toggle between raw and expanded view
        const rawTab = document.getElementById('raw-tab');
        const expandedTab = document.getElementById('expanded-tab');
        
        if (rawTab.classList.contains('active')) {
            rawTab.classList.remove('active');
            document.getElementById('raw-content').classList.remove('show', 'active');
            
            expandedTab.classList.add('active');
            document.getElementById('expanded-content').classList.add('show', 'active');
            
            // Update expanded view
            updateExpandedView();
        } else {
            expandedTab.classList.remove('active');
            document.getElementById('expanded-content').classList.remove('show', 'active');
            
            rawTab.classList.add('active');
            document.getElementById('raw-content').classList.add('show', 'active');
        }
    }
    
    function showDeleteConfirmation() {
        const deleteModal = new bootstrap.Modal(document.getElementById('deletePromptModal'));
        deleteModal.show();
    }
    
    function deletePrompt() {
        // Send DELETE request
        fetch(`/api/prompts/${promptId}`, {
            method: 'DELETE'
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to delete prompt');
            }
            return response.json();
        })
        .then(data => {
            // Success - redirect to prompts list
            showToast('Prompt deleted successfully');
            
            // Redirect after a short delay
            setTimeout(() => {
                window.location.href = '/manage/prompts';
            }, 1000);
        })
        .catch(error => {
            console.error('Error deleting prompt:', error);
            showToast('Error deleting prompt: ' + error.message, 'danger');
        });
    }
    
    function showWarnings(warnings) {
        const warningsCard = document.getElementById('warnings-card');
        const warningsContainer = document.getElementById('warnings');
        
        // Create warning message HTML
        let html = '<ul class="list-group">';
        
        warnings.forEach(warning => {
            html += `
                <li class="list-group-item list-group-item-warning">
                    <i class="bi bi-exclamation-triangle-fill me-2"></i>
                    ${warning}
                </li>
            `;
        });
        
        html += '</ul>';
        
        // Update warnings container and show card
        warningsContainer.innerHTML = html;
        warningsCard.style.display = 'block';
    }
    
    function hideWarnings() {
        const warningsCard = document.getElementById('warnings-card');
        warningsCard.style.display = 'none';
    }
    
    // Load all prompts for autocomplete
    function loadAllPrompts() {
        fetch('/api/prompts/all')
            .then(response => response.json())
            .then(prompts => {
                // Store the prompts for autocomplete
                allPrompts = prompts.map(p => p.id);
                console.log(`Loaded ${allPrompts.length} prompts for autocomplete`);
            })
            .catch(error => {
                console.error('Error loading prompts for autocomplete:', error);
            });
    }
    
    // Set up the prompt completion functionality
    function setupPromptCompletion() {
        // Define our custom hint function
        window.promptHint = function(editor, options) {
            const cursor = editor.getCursor();
            const line = editor.getLine(cursor.line);
            const lineBeforeCursor = line.substring(0, cursor.ch);
            
            // Check if we're typing after [[ 
            const match = lineBeforeCursor.match(/\[\[([^\]]*?)$/);
            if (!match) return null;
            
            const prefix = match[1]; // The text after [[ but before cursor
            
            // Filter prompts based on prefix
            const filteredPrompts = allPrompts.filter(prompt => 
                prompt.toLowerCase().includes(prefix.toLowerCase())
            );
            
            if (filteredPrompts.length === 0) return null;
            
            return {
                list: filteredPrompts.map(prompt => ({ 
                    text: prompt + "]]", 
                    displayText: prompt 
                })),
                from: { line: cursor.line, ch: cursor.ch - prefix.length },
                to: cursor
            };
        };
        
        // Listen for [[ key sequence to trigger autocomplete
        editor.on('keyup', function(cm, event) {
            const cursor = cm.getCursor();
            const line = cm.getLine(cursor.line);
            const lineBeforeCursor = line.substring(0, cursor.ch);
            
            // Check if we just typed [[ or are within a [[ ]] pair
            if (lineBeforeCursor.endsWith('[[') || lineBeforeCursor.match(/\[\[([^\]]*?)$/)) {
                cm.showHint({ hint: promptHint, completeSingle: false });
            }
        });
    }
</script>
{% endblock %}

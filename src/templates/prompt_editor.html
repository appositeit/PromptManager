 class="text-muted">Use Ctrl+Space for auto-completion of prompt names</small>
                </div>

                <h6>Escaping Characters</h6>
                <div class="mb-3">
                    Use backslash <code>\</code> to escape special characters:<br>
                    <code>\* \_ \[ \] \( \) \# \+ \- \. \!</code>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
    /* Smart responsive layout that adapts to content height */
    #editor {
        height: calc(100vh - 155px); /* Subtract tighter navbar, reduced padding, and tab height */
        min-height: 400px;
    }
    
    .CodeMirror {
        height: 100%;
        font-size: 14px;
        line-height: 1.6;
    }
    
    /* Style the tabs */
    #editor-tabs .nav-link {
        font-size: 0.9rem;
        padding: 0.5rem 1rem;
    }
    
    /* Fix for expanded content view overflow issue */
    #expanded-content {
        background-color: #fff;
    }
    
    /* Preview styling for expanded view */
    #preview {
        background-color: #fff;
        height: calc(100vh - 150px); /* Match editor height */
        min-height: 400px;
        padding: 15px;
        width: 100%;
        overflow-y: auto; /* Allow scrolling within preview if needed */
        border: 1px solid #dee2e6;
        border-radius: 4px;
        font-size: 14px; /* Base font size, matches CodeMirror */
        line-height: 1.6; /* Base line height, matches CodeMirror */
    }
    
    /* Ensure all child elements inherit the base font size and line height by default */
    #preview * {
        font-size: inherit;
        line-height: inherit;
    }
    
    /* Specific styling for headings within the preview to make them proportional */
    #preview h1 {
        font-size: 1.8em !important; /* Approx 25px if base is 14px */
        margin-top: 0.20em; /* Reduced from 0.34em (approx 0.6 * 0.34) */
        margin-bottom: 0.20em; /* Reduced from 0.34em */
    }
    #preview h2 {
        font-size: 1.5em !important; /* Approx 21px */
        margin-top: 0.25em; /* Reduced from 0.42em (approx 0.6 * 0.42) */
        margin-bottom: 0.25em; /* Reduced from 0.42em */
    }
    #preview h3 {
        font-size: 1.17em !important; /* Approx 16.4px */
        margin-top: 0.30em;  /* Reduced from 0.5em (0.6 * 0.5) */
        margin-bottom: 0.30em;  /* Reduced from 0.5em */
    }
    #preview h4 {
        font-size: 1em !important; /* Approx 14px */
        margin-top: 0.40em; /* Reduced from 0.67em (approx 0.6 * 0.67) */
        margin-bottom: 0.40em; /* Reduced from 0.67em */
    }
    #preview h5 {
        font-size: 0.83em !important; /* Approx 11.6px */
        margin-top: 0.50em; /* Reduced from 0.84em (approx 0.6 * 0.84) */
        margin-bottom: 0.50em; /* Reduced from 0.84em */
    }
    #preview h6 {
        font-size: 0.67em !important; /* Approx 9.4px */
        margin-top: 0.70em; /* Reduced from 1.17em (approx 0.6 * 1.17) */
        margin-bottom: 0.70em; /* Reduced from 1.17em */
    }
    
    /* Ensure markdown content in preview is properly styled */
    #preview pre {
        background-color: #f8f9fa;
        padding: 10px;
        border-radius: 4px;
        overflow-x: auto;
    }
    
    #preview code {
        background-color: #f8f9fa;
        padding: 2px 4px;
        border-radius: 3px;
        font-family: 'Fira Code', monospace;
    }
    
    /* Make metadata elements smaller and more compact */
    .form-control-sm {
        height: 30px;
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
    }
    
    .card-header {
        padding: 0.5rem 1rem;
    }
    
    .small {
        font-size: 0.875rem;
    }
    
    /* Style the sidebar cards to be more compact */
    .col-md-3 .card {
        font-size: 0.9rem;
    }
    
    .col-md-3 .card-body {
        padding: 0.75rem;
    }
    
    .col-md-3 .form-label {
        margin-bottom: 0.25rem;
        font-weight: 500;
    }
    
    /* Make the list groups in sidebar more compact */
    .col-md-3 .list-group-item {
        padding: 0.5rem 0.75rem;
    }
    
    /* Smart sidebar: only show scrollbar when needed */
    @media (min-width: 768px) {
        .col-md-3 {
            max-height: calc(100vh - 90px); /* Account for tighter navbar and reduced padding */
            overflow-y: auto; /* Only show scrollbar when content overflows */
        }
    }
    
    /* Fixed width save button to prevent UI jumps */
    #save-btn {
        min-width: 100px;
    }
    
    /* Style for the autocomplete dropdown */
    .CodeMirror-hints {
        position: absolute;
        z-index: 10;
        overflow: hidden;
        list-style: none;
        margin: 0;
        padding: 0;
        max-height: 20em;
        overflow-y: auto;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    
    .CodeMirror-hint {
        margin: 0;
        padding: 4px 8px;
        white-space: pre;
        cursor: pointer;
        font-size: 0.9em;
    }
    
    .CodeMirror-hint-active {
        background-color: #007bff;
        color: white;
    }
    
    /* Ensure the custom hint dropdown is above other elements */
    .CodeMirror-hints {
        z-index: 1051; /* Higher than Bootstrap modals (1050) */
    }
    
    /* Markdown cheat sheet styling */
    .markdown-cheat-sheet {
        font-size: 0.75rem;
    }
    
    .markdown-cheat-sheet code {
        background-color: #f8f9fa;
        padding: 1px 3px;
        border-radius: 2px;
        font-size: 0.7rem;
        color: #495057;
        border: 1px solid #e9ecef;
    }
    
    .markdown-cheat-sheet .text-muted {
        font-size: 0.65rem;
        font-weight: 500;
    }
    
    #markdown-help-btn {
        padding: 0.125rem 0.25rem;
        font-size: 0.7rem;
        line-height: 1;
    }
    
    /* Markdown help modal styling */
    #markdownHelpModal .modal-body h6 {
        color: #495057;
        font-weight: 600;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        border-bottom: 1px solid #dee2e6;
        padding-bottom: 0.25rem;
    }
    
    #markdownHelpModal .modal-body h6:first-child {
        margin-top: 0;
    }
    
    #markdownHelpModal .modal-body h6.text-primary {
        color: #0d6efd !important;
        border-bottom-color: #0d6efd;
    }
    
    #markdownHelpModal .modal-body code {
        background-color: #f8f9fa;
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 0.875rem;
        color: #495057;
        border: 1px solid #e9ecef;
    }
    
    #markdownHelpModal .modal-body pre {
        background-color: #f8f9fa;
        padding: 0.75rem;
        border-radius: 0.375rem;
        border: 1px solid #e9ecef;
        font-size: 0.8rem;
    }
    
    #markdownHelpModal .modal-body pre code {
        background-color: transparent;
        padding: 0;
        border: none;
        font-size: inherit;
    }
</style>
{% endblock %}

{% block page_specific_js %}
<script>
    let editor;
    let currentPromptData = null;
    let newPromptModal = null;
    let directories = [];
    const promptId = document.getElementById('prompt-true-unique-id').textContent;
    const saveButton = document.getElementById('save-btn');
    const saveStatusIcon = saveButton ? saveButton.querySelector('i') : null;
    const originalSaveButtonText = saveButton ? saveButton.innerHTML : '';
    const descriptionInput = document.getElementById('prompt-description');
    const tagsInput = document.getElementById('prompt-tags');
    const isCompositeBadge = document.getElementById('is-composite-badge');
    const lastUpdatedSpan = document.getElementById('last-updated');
    const promptDirectorySpan = document.getElementById('prompt-directory');
    const dependenciesDiv = document.getElementById('dependencies');
    const referencedByDiv = document.getElementById('referenced-by');
    const warningsDiv = document.getElementById('warnings');
    const warningsCard = document.getElementById('warnings-card');
    const rawContentTab = document.getElementById('raw-tab');
    const expandedContentTab = document.getElementById('expanded-tab');
    const rawContentPane = document.getElementById('raw-content');
    const expandedContentPane = document.getElementById('expanded-content');
    const editorTabs = document.getElementById('editor-tabs');

    let saveTimeout;
    let isSaving = false;

    function setSaveButtonState(state, message = '') {
        if (!saveButton || !saveStatusIcon) return;

        if (state === 'saving') {
            isSaving = true;
            saveButton.disabled = true;
            saveButton.innerHTML = '<i class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></i> Saving...';
        } else if (state === 'saved') {
            isSaving = false;
            saveButton.disabled = false;
            saveButton.innerHTML = '<i class="bi bi-check-lg"></i> Saved';
            setTimeout(() => {
                if (!isSaving) saveButton.innerHTML = originalSaveButtonText;
            }, 2000);
        } else if (state === 'error') {
            isSaving = false;
            saveButton.disabled = false;
            saveButton.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Error';
            // Optionally revert to original after a delay, or require user interaction
        } else { // idle
            isSaving = false;
            saveButton.disabled = false;
            saveButton.innerHTML = originalSaveButtonText;
        }
    }

    function savePromptData(showToastNotification = true) {
        if (!currentPromptData) return;
        setSaveButtonState('saving');

        const payload = {
            content: editor.getValue(),
            description: descriptionInput.value,
            tags: tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag)
        };

        fetch(`/api/prompts/${promptId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => {
            if (!response.ok) {
                response.text().then(text => {
                    console.error(`Error response body for PUT /api/prompts/${promptId}:`, text);
                    showToast(`Save failed: ${text || response.statusText}`, 'error');
                    setSaveButtonState('error');
                });
                throw new Error(`Save failed: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            currentPromptData = data; // Update with response which might include new last_updated
            updateMetadataUI();
            if (showToastNotification) {
                showToast('Prompt saved successfully!', 'success');
            }
            setSaveButtonState('saved');
            detectPromptType(); 
            // After saving, re-fetch dependencies and referenced_by as they might have changed
            // if inclusions were added/removed, or if this prompt's ID was referenced elsewhere.
            // However, for simple content/metadata save, this is not strictly necessary unless
            // the prompt type (composite/standard) changes, which is handled by detectPromptType.
            // For now, we rely on detectPromptType to refresh expanded view if needed.
        })
        .catch(error => {
            console.error('Error saving prompt:', error);
            if (showToastNotification) {
                showToast(`Error saving prompt: ${error.message}`, 'error');
            }
            setSaveButtonState('error');
        });
    }
    
    function loadPromptData() {
        fetch(`/api/prompts/${promptId}`)
            .then(response => {
                if (!response.ok) {
                    response.text().then(text => console.error(`Error response body for /api/prompts/${promptId}:`, text));
                    throw new Error(`Prompt not found or API error: ${response.status} ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('[DEBUG] prompt_editor.js: Received data from /api/prompts/', promptId, data); // Log received data
                currentPromptData = data;
                
                if (editor) {
                    console.log('[DEBUG] prompt_editor.js: Setting editor value:', data.content); // Log content to be set
                    editor.setValue(data.content || '');
                    console.log('[DEBUG] prompt_editor.js: Editor value set.'); // Confirm value set
                    // editor.clearHistory(); // Optional: clear undo history after loading
                }
                updateMetadataUI();
                updateDependenciesUI();
                updateReferencedByUI();
                updateWarningsUI();
                detectPromptType();
                updateExpandedPreview(); // Initial preview update
            })
            .catch(error => {
                console.error('Error loading prompt data:', error);
                showToast(`Error loading prompt: ${error.message}`, 'error');
                if (editor) editor.setValue(`Error loading prompt: ${error.message}`);
            });
    }

    function loadDirectories() {
        return fetch('/api/prompts/directories/all')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to load directories: ${response.status} ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                directories = data;
                // Populate new prompt modal if it exists
                if (newPromptModal) {
                    newPromptModal.populateDirectorySelect(directories);
                }
                return directories;
            })
            .catch(error => {
                console.error('Error loading directories:', error);
                throw error;
            });
    }

    function updateMetadataUI() {
        if (!currentPromptData) return;
        descriptionInput.value = currentPromptData.description || '';
        tagsInput.value = currentPromptData.tags ? currentPromptData.tags.join(', ') : '';
        if (isCompositeBadge) {
            isCompositeBadge.textContent = currentPromptData.is_composite ? 'Composite' : 'Standard';
            isCompositeBadge.className = `badge rounded-pill me-2 ${currentPromptData.is_composite ? 'bg-primary' : 'bg-secondary'}`;
        }
        if (lastUpdatedSpan) {
            lastUpdatedSpan.textContent = currentPromptData.last_updated ? dayjs(currentPromptData.last_updated).fromNow() : '-';
        }
        if (promptDirectorySpan && currentPromptData.directory_info) {
            // Show full path in Directory field, with short name in tooltip
            const directoryPath = currentPromptData.directory_info.path || '-';
            const directoryName = currentPromptData.directory_info.name || currentPromptData.directory_name || currentPromptData.directory_info.path || '-';
            promptDirectorySpan.textContent = directoryPath;
            promptDirectorySpan.title = directoryName; // Short name in tooltip
        }
    }

    function updateDependenciesUI() {
        if (!currentPromptData || !dependenciesDiv) return;
        dependenciesDiv.innerHTML = ''; // Clear previous
        if (currentPromptData.dependencies && currentPromptData.dependencies.length > 0) {
            const list = document.createElement('ul');
            list.className = 'list-group list-group-flush';
            currentPromptData.dependencies.forEach(dep => {
                const item = document.createElement('li');
                item.className = 'list-group-item';
                const link = document.createElement('a');
                link.href = `/prompts/${dep.id}`;
                link.textContent = dep.id;
                item.appendChild(link);
                if (dep.is_missing) {
                    const missingBadge = document.createElement('span');
                    missingBadge.className = 'badge bg-danger ms-2';
                    missingBadge.textContent = 'Missing';
                    item.appendChild(missingBadge);
                }
                list.appendChild(item);
            });
            dependenciesDiv.appendChild(list);
                        } else {
            dependenciesDiv.innerHTML = '<p class="text-muted small">No dependencies found.</p>';
        }
    }

    function updateReferencedByUI() {
        if (!currentPromptData || !referencedByDiv) return;
        referencedByDiv.innerHTML = '<p class="text-muted small">Loading references...</p>'; // Show loading indicator
        
        fetch(`/api/prompts/${promptId}/referenced_by`)
            .then(response => response.json())
            .then(references => {
                referencedByDiv.innerHTML = ''; // Clear loading/previous
                if (references && references.length > 0) {
                    const list = document.createElement('ul');
                    list.className = 'list-group list-group-flush';
                    references.forEach(ref => {
                        const item = document.createElement('li');
                        item.className = 'list-group-item';
                        const link = document.createElement('a');
                        link.href = `/prompts/${ref.id}`;
                        link.textContent = ref.id;
                        item.appendChild(link);
                        // No type for referenced by as it's always another prompt.
                        list.appendChild(item);
                    });
                    referencedByDiv.appendChild(list);
                } else {
                    referencedByDiv.innerHTML = '<p class="text-muted small">Not referenced by any other prompts.</p>';
                }
            })
            .catch(error => {
                console.error('Error loading referenced_by:', error);
                referencedByDiv.innerHTML = '<p class="text-danger small">Error loading references.</p>';
            });
    }
    
    function updateWarningsUI() {
        if (!currentPromptData || !warningsDiv || !warningsCard) return;
        warningsDiv.innerHTML = ''; // Clear previous warnings
        let hasWarnings = false;

        if (currentPromptData.dependencies) {
            currentPromptData.dependencies.forEach(dep => {
                if (dep.is_missing) {
                    const warning = document.createElement('div');
                    warning.className = 'alert alert-warning p-2 small';
                    warning.innerHTML = `<i class="bi bi-exclamation-triangle-fill me-1"></i> Missing dependency: <strong>${dep.id}</strong>. This prompt might not expand correctly.`;
                    warningsDiv.appendChild(warning);
                    hasWarnings = true;
                }
            });
        }
        // Add more warning conditions here if needed

        warningsCard.style.display = hasWarnings ? 'block' : 'none';
    }


    function detectPromptType() {
        if (!editor || !currentPromptData) return;
        const content = editor.getValue();
        const isComposite = /\[\[.*?\]\]/.test(content);
        
        if (currentPromptData.is_composite !== isComposite) {
            currentPromptData.is_composite = isComposite; // Update local state
            updateMetadataUI(); // Refresh badge
            // If it changed, it implies a save is probably needed to persist this.
            // And expanded view needs update.
            updateExpandedPreview();
        }
        
        // Enable expanded view tab for all prompts since it's used for markdown rendering
        if (expandedContentTab) {
            expandedContentTab.classList.remove('disabled');
            expandedContentTab.removeAttribute('tabindex');
            expandedContentTab.setAttribute('title', 'View content with markdown rendering and inclusions expanded');
        }
    }

    function initializeEditor() {
        editor = CodeMirror(document.getElementById('editor'), {
            mode: 'markdown',
            theme: 'monokai',
            lineNumbers: true,
            lineWrapping: true,
            autofocus: true,
            placeholder: "Enter your prompt content here. Use [[prompt_name]] to include other prompts...",
            extraKeys: {
                "Ctrl-Space": "autocomplete",
                "Cmd-S": function(cm) { savePromptData(true); },
                "Ctrl-S": function(cm) { savePromptData(true); },
                "Tab": function(cm) {
                    const cursor = cm.getCursor();
                    const token = cm.getTokenAt(cursor);
                    const line = cm.getLine(cursor.line);
                    const textBeforeCursor = line.substring(0, cursor.ch);

                    // Trigger autocomplete if:
                    // 1. We are at the end of a line that ends with '[['
                    // 2. The current token starts with '[[' and is not yet ']]'
                    // 3. The text immediately before the cursor is '[['
                    if (textBeforeCursor.endsWith('[[') || (token.string.startsWith('[[') && !token.string.endsWith(']]'))) {
                        cm.execCommand("autocomplete");
                    } else {
                        // Default tab behavior (e.g., insert tab character or move focus)
                        // CodeMirror.Pass allows other keymaps or default browser behavior to handle it.
                        // Using editor.execCommand('indentMore') or cm.replaceSelection('\\t') might be alternatives for explicit tab insertion.
                        return CodeMirror.Pass; 
                    }
                }
            },
            hintOptions: { hint: window.promptHint }
        });

        // Add inputRead event to trigger autocompletion immediately when typing [[
        editor.on('inputRead', function(cm, change) {
            if (change.text.length === 1) {
                const cursor = cm.getCursor();
                const line = cm.getLine(cursor.line);
                
                // If user just typed the second [ of [[ 
                if (change.text[0] === '[' && cursor.ch >= 2 && line.substring(cursor.ch - 2, cursor.ch) === '[[') {
                    // Trigger autocomplete immediately (no delay)
                    cm.execCommand('autocomplete');
                }
            }
        });

        editor.on('change', function() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => savePromptData(false), 1500); // Auto-save after 1.5s of inactivity
            detectPromptType(); // Check if it became composite/standard
        });
    }
    
    function getExpandedContent(callback) {
        fetch(`/api/prompts/expand`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ prompt_id: promptId })
        })
        .then(response => {
                if (!response.ok) throw new Error(`Failed to fetch expanded content: ${response.status} ${response.statusText}`);
            return response.json();
        })
            .then(data => callback(null, data.expanded_content))
        .catch(error => {
                console.error("Error fetching expanded content:", error);
                callback(error, null);
            });
    }

    function updateExpandedPreview() {
        const previewDiv = document.getElementById('preview');
        if (!previewDiv) return;

        if (!currentPromptData) {
            previewDiv.innerHTML = '<div class="alert alert-warning">No content available.</div>';
            return;
        }

        if (currentPromptData.is_composite) {
            previewDiv.innerHTML = '<div class="text-center p-3"><div class="spinner-border spinner-border-sm" role="status"></div><span class="ms-2">Loading expanded content...</span></div>';
            getExpandedContent((error, expandedContent) => {
                if (error) {
                    previewDiv.innerHTML = `<div class="alert alert-danger">Error loading expanded content: ${error.message}</div>`;
                } else {
                    previewDiv.innerHTML = marked.parse(expandedContent || '');
                }
            });
        } else {
            // For non-composite prompts, just render the raw content as markdown
            previewDiv.innerHTML = marked.parse(editor.getValue() || '');
        }
    }

    function showRenameModal() {
        const newPromptIdInput = document.getElementById('new-prompt-id');
        // Extract just the name part from the full ID path
        const currentName = promptId.split('/').pop().replace('.md', '');
        newPromptIdInput.value = currentName; // Pre-fill with current name only
        const renameModal = new bootstrap.Modal(document.getElementById('renamePromptModal'));
        const renameWarning = document.getElementById('rename-warning');
        const renameWarningText = document.getElementById('rename-warning-text');
        renameWarning.style.display = 'none'; 

        // Check if it's referenced
        fetch(`/api/prompts/${promptId}/referenced_by`)
            .then(response => response.json())
            .then(references => {
                if (references && references.length > 0) {
                    renameWarningText.textContent = `This prompt is referenced by ${references.length} other prompt(s). Renaming will attempt to update these references.`;
                    renameWarning.style.display = 'block';
                }
            });
        renameModal.show();
    }
    
    function showDeleteModal() {
        const deleteModal = new bootstrap.Modal(document.getElementById('deletePromptModal'));
        deleteModal.show();
    }
    
    function performRename() {
        const newPromptId = document.getElementById('new-prompt-id').value.trim();
        if (!newPromptId || newPromptId === promptId) {
            showToast('New name is invalid or same as current.', 'warning');
            return;
        }
        if (!/^[a-zA-Z0-9_-]+$/.test(newPromptId)) {
            showToast('New name contains invalid characters. Use only letters, numbers, underscores, and hyphens.', 'error');
                    return;
                }
                
        fetch(`/api/prompts/rename`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ old_id: promptId, new_name: newPromptId })
        })
        .then(response => {
            if (!response.ok) {
                response.json().then(err => {
                    showToast(`Rename failed: ${err.detail || response.statusText}`, 'error');
                }).catch(() => {
                    showToast(`Rename failed: ${response.statusText}`, 'error');
                });
                throw new Error('Rename failed');
            }
            return response.json();
        })
        .then(data => {
            showToast(data.message || 'Prompt renamed successfully!', 'success');
            // Redirect to the new prompt ID (use the ID from the response)
            const newPromptFullId = data.id || newPromptId;
            window.location.href = `/prompts/${encodeURIComponent(newPromptFullId)}`;
        })
        .catch(error => {
            console.error('Error renaming prompt:', error);
            // Toast already shown if response.ok was false and had json
        });
    }

    function performDelete() {
        fetch(`/api/prompts/${promptId}`, { method: 'DELETE' })
        .then(response => {
            if (!response.ok) {
                response.json().then(err => {
                    showToast(`Delete failed: ${err.detail || response.statusText}`, 'error');
                }).catch(() => {
                    showToast(`Delete failed: ${response.statusText}`, 'error');
                });
                throw new Error('Delete failed');
            }
            return response.json();
        })
        .then(data => {
            showToast(data.message || 'Prompt deleted successfully!', 'success');
            window.location.href = '/manage/prompts'; // Redirect to prompt list
        })
        .catch(error => console.error('Error deleting prompt:', error));
    }

    function copyToClipboard(content, successMessage = 'Content copied to clipboard!') {
        // Check if the Clipboard API is available
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(content)
                .then(() => showToast(successMessage, 'success'))
                .catch(err => {
                    showToast('Failed to copy content.', 'error');
                    console.error('Error copying content: ', err);
                });
        } else {
            // Fallback method for older browsers or insecure contexts
            try {
                const textArea = document.createElement('textarea');
                textArea.value = content;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                if (document.execCommand('copy')) {
                    showToast(successMessage, 'success');
                } else {
                    showToast('Failed to copy content. Please manually select and copy.', 'error');
                }
                
                document.body.removeChild(textArea);
            } catch (err) {
                showToast('Copy functionality not available. Please manually select and copy.', 'error');
                console.error('Error with fallback copy method: ', err);
            }
        }
    }

    function getExpandedMarkdown(callback) {
        fetch(`/api/prompts/expand`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ prompt_id: promptId })
        })
        .then(response => {
            if (!response.ok) throw new Error(`Failed to get expanded content: ${response.status} ${response.statusText}`);
            return response.json();
        })
        .then(data => callback(null, data.expanded_content))
        .catch(error => {
            console.error("Error fetching expanded markdown:", error);
            callback(error, null);
        });
    }

    function copyContent() {
        // New behavior: Always get expanded markdown (inclusions resolved but still markdown format)
        getExpandedMarkdown((error, expandedContent) => {
            if (error || !expandedContent) {
                // Fallback to raw editor content if API call fails
                console.warn('Failed to get expanded content, falling back to raw content:', error);
                copyToClipboard(editor.getValue(), 'Content copied to clipboard (raw)!');
            } else {
                copyToClipboard(expandedContent, 'Content copied to clipboard (expanded)!');
            }
        });
    }

    function copyRenderedContent() {
        // Alt+Shift+C behavior: Get rendered HTML content as text
        const previewDiv = document.getElementById('preview');
        if (previewDiv && previewDiv.innerText.trim()) {
            copyToClipboard(previewDiv.innerText, 'Rendered content copied to clipboard!');
        } else {
            // Fallback: render current content to preview first, then copy
            updateExpandedPreview();
            setTimeout(() => {
                const previewDiv = document.getElementById('preview');
                if (previewDiv && previewDiv.innerText.trim()) {
                    copyToClipboard(previewDiv.innerText, 'Rendered content copied to clipboard!');
                } else {
                    // Ultimate fallback to raw content
                    copyToClipboard(editor.getValue(), 'Content copied to clipboard (raw)!');
                }
            }, 500); // Give time for preview to update
        }
    }
    
    function toggleView() {
        console.log('[DEBUG] toggleView called.');
        const rawTabInstance = bootstrap.Tab.getOrCreateInstance(rawContentTab);
        const expandedTabInstance = bootstrap.Tab.getOrCreateInstance(expandedContentTab);

        if (!rawTabInstance || !expandedTabInstance) {
            console.error('[DEBUG] toggleView: Critical error - Bootstrap Tab instances could not be found or created.');
            showToast("Error: Tab functionality could not be initialized.", "error");
            return;
        }
        console.log(`[DEBUG] toggleView: rawContentPane.classList.contains('show') = ${rawContentPane.classList.contains('show')}`);
        if (currentPromptData) {
            console.log(`[DEBUG] toggleView: currentPromptData exists. is_composite = ${currentPromptData.is_composite}`);
        } else {
            console.log('[DEBUG] toggleView: currentPromptData is null/undefined.');
        }

        if (rawContentPane.classList.contains('show')) {
            if (currentPromptData) {
                console.log('[DEBUG] toggleView: Attempting to show expanded tab.');
                updateExpandedPreview(); // Ensure it's fresh before showing
                expandedTabInstance.show();
            } else {
                console.log('[DEBUG] toggleView: Cannot show expanded tab - data not loaded');
                showToast('Cannot show expanded view - data is still loading.', 'info');
            }
        } else {
            console.log('[DEBUG] toggleView: Attempting to show raw tab.');
            rawTabInstance.show();
        }
    }
    
    function setupSearchReplace() {
        const searchReplaceBtn = document.getElementById('search-replace-btn');
        if (searchReplaceBtn) {
            searchReplaceBtn.addEventListener('click', () => {
                if (editor && rawContentPane.classList.contains('show')) {
                    editor.execCommand("replace");
                } else {
                    showToast("Search/Replace is only available in Raw Content view.", "info");
                }
            });
        }
    }

    // Define our custom hint function with display name support
    window.promptHint = function(cm, options) {
        return new Promise(function(accept) {
            const cursor = cm.getCursor();
            const token = cm.getTokenAt(cursor);
            let searchTerm = '';
            let fromPos = null;

            // Check if we are inside a [[ ]] block
            if (token.string.startsWith('[[')) {
                searchTerm = token.string.substring(2);
                fromPos = CodeMirror.Pos(cursor.line, token.start + 2); // Start after '[['
            } else if (cm.getLine(cursor.line).substring(0, cursor.ch).includes('[[')) {
                // More robust check if cursor is after '[[' but not necessarily at start of token
                const lineContent = cm.getLine(cursor.line);
                const lastOpenBracket = lineContent.lastIndexOf('[[', cursor.ch - 1);
                if (lastOpenBracket !== -1) {
                    const potentialSearchTerm = lineContent.substring(lastOpenBracket + 2, cursor.ch);
                    if (!potentialSearchTerm.includes(']]')) { // Ensure we are not after a closing bracket
                        searchTerm = potentialSearchTerm;
                        fromPos = CodeMirror.Pos(cursor.line, lastOpenBracket + 2);
                    }
                }
            }

            console.log(`[PromptHint] Search term determined: '${searchTerm}'`); // Log for search term

            // If empty search term, we should still show all completions 
            // (this happens right after typing '[[')
            const isEmptySearch = searchTerm.trim() === '';
            console.log(`[PromptHint] Search term is ${isEmptySearch ? 'empty' : `'${searchTerm}'`}`);
            
            // We build the request URL differently based on whether we have a search term or not
            const fetchUrl = isEmptySearch 
                ? `/api/prompts/search_suggestions?exclude=${encodeURIComponent(promptId)}`
                : `/api/prompts/search_suggestions?query=${encodeURIComponent(searchTerm)}&exclude=${encodeURIComponent(promptId)}`;

            // Fetch suggestions from the API
            fetch(fetchUrl)
                .then(res => res.json())
                .then(function(data) {
                    if (data && data.length > 0) {
                        // Sort the suggestions by display name for better UX
                        const sortedData = [...data].sort((a, b) => {
                            const displayA = a.display_name || a.id;
                            const displayB = b.display_name || b.id;
                            return displayA.localeCompare(displayB);
                        });
                        
                        const hints = sortedData.map(item => {
                            const displayName = item.display_name || item.id;
                            const fullId = item.id;
                            
                            return {
                                text: fullId + ']]', // Insert the full ID
                                displayText: displayName !== fullId ? `${displayName} (${fullId})` : displayName, // Show display name with ID if different
                                hint: function(cm, data, completion) {
                                    // Custom completion handler - insert the full ID
                                    cm.replaceRange(completion.text, data.from, data.to, "complete");
                                }
                            };
                        });
                        
                        // Determine the 'from' and 'to' positions for replacement
                        const from = fromPos;
                        const to = cursor;

                        return accept({list: hints, from: from, to: to});
                    }
                    return accept(null);
                })
                .catch(function() {
                    return accept(null);
                });
        });
    };


    // Initial load
    document.addEventListener('DOMContentLoaded', function() {
        initializeEditor();
        const searchReplace = new SearchReplace(editor); // Instantiate SearchReplace
        
        // Load prompt data and directories
        Promise.all([
            loadPromptData(),
            loadDirectories()
        ]).then(() => {
            console.log('Successfully loaded prompt data and directories');
            
            // Initialize new prompt modal with current directory context
            const currentDirectory = currentPromptData ? currentPromptData.directory : null;
            newPromptModal = new NewPromptModal('prompt_editor', currentDirectory);
            newPromptModal.populateDirectorySelect(directories);
        }).catch(error => {
            console.error('Error during initialization:', error);
        });

        if (saveButton) {
            saveButton.addEventListener('click', () => savePromptData(true));
        }
        if (descriptionInput) {
            descriptionInput.addEventListener('input', () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => savePromptData(false), 1500);
            });
        }
        if (tagsInput) {
            tagsInput.addEventListener('input', () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => savePromptData(false), 1500);
            });
        }
        
        const copyBtn = document.getElementById('copy-btn');
        if (copyBtn) copyBtn.addEventListener('click', copyContent);

        const toggleViewBtn = document.getElementById('toggle-view-btn');
        if (toggleViewBtn) toggleViewBtn.addEventListener('click', toggleView);

        const renameBtn = document.getElementById('rename-btn');
        if (renameBtn) renameBtn.addEventListener('click', showRenameModal);
        
        const confirmRenameBtn = document.getElementById('confirm-rename-btn');
        if (confirmRenameBtn) confirmRenameBtn.addEventListener('click', performRename);

        const deleteBtn = document.getElementById('delete-btn');
        if (deleteBtn) deleteBtn.addEventListener('click', showDeleteModal);
        
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
        if (confirmDeleteBtn) confirmDeleteBtn.addEventListener('click', performDelete);
        
        const searchReplaceBtn = document.getElementById('search-replace-btn');
        if (searchReplaceBtn) {
            searchReplaceBtn.addEventListener('click', () => {
                if (rawContentPane.classList.contains('show')) {
                    searchReplace.showDialog();
                } else {
                    showToast("Search/Replace is only available in Raw Content view. Please switch to 'Raw Content' tab first.", "info");
                }
            });
        }

        // Ensure expanded preview updates when its tab is shown
        if (expandedContentTab) {
            expandedContentTab.addEventListener('shown.bs.tab', function (event) {
                updateExpandedPreview();
            });
        }
        
        // Markdown help modal
        const markdownHelpBtn = document.getElementById('markdown-help-btn');
        if (markdownHelpBtn) {
            const markdownHelpModal = new bootstrap.Modal(document.getElementById('markdownHelpModal'));
            markdownHelpBtn.addEventListener('click', function () {
                markdownHelpModal.show();
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.altKey) {
                switch (event.key.toLowerCase()) {
                    case 'n':
                        // Ensure not in an input field where Alt+N might be legitimate
                        if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'SELECT') {
                            return;
                        }
                        event.preventDefault();
                        showNewPromptModal('prompt_editor', currentPromptData ? currentPromptData.directory : null);
                        break;
                    case 's':
                        event.preventDefault();
                        saveButton.click();
                        break;
                    case 'c':
                        event.preventDefault();
                        if (event.shiftKey) {
                            // Alt+Shift+C: Copy rendered content
                            copyRenderedContent();
                        } else {
                            // Alt+C: Copy expanded markdown
                            copyBtn.click();
                        }
                        break;
                    case 't':
                        event.preventDefault();
                        toggleViewBtn.click();
                        break;
                    case 'r':
                        event.preventDefault();
                        searchReplaceBtn?.click();
                        break;
                    case 'b':
                        event.preventDefault();
                        document.getElementById('back-btn')?.click();
                        break;
                    case 'm':
                        event.preventDefault();
                        renameBtn.click();
                        break;
                }
            }
        });

    });
</script>
{% endblock %}

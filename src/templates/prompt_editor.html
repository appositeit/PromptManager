{% extends "base.html" %}

{% block title %}Prompt Editor{% endblock %}

{% block extra_js_head %}
<script src="/static/js/utils.js"></script>
{% endblock %}

{% block header_title %}{{ prompt_id }}{% endblock %}

{% block header_actions %}
<div class="btn-group me-2">
    <a href="/manage/prompts" class="btn btn-outline-secondary" id="back-btn" title="Back to Prompt List (Alt+B)">
        <i class="bi bi-arrow-left"></i> Back to List
    </a>
</div>
<div class="btn-group">
    <button id="copy-btn" class="btn btn-outline-primary" title="Copy content to clipboard (Alt+C)">
        <i class="bi bi-clipboard"></i> Copy
    </button>
    <button id="toggle-view-btn" class="btn btn-outline-primary" title="Toggle between raw and expanded view (Alt+T)">
        <i class="bi bi-eye"></i> Toggle View
    </button>
    <button id="search-replace-btn" class="btn btn-outline-primary" title="Search and Replace (Alt+R)">
        <i class="bi bi-search"></i> Search/Replace
    </button>
    <button id="rename-btn" class="btn btn-outline-primary" title="Rename this prompt">
        <i class="bi bi-pencil-square"></i> Rename
    </button>
    <button id="save-btn" class="btn btn-outline-success min-width-100" title="Save changes (Alt+S)">
        <i class="bi bi-save"></i> Save
    </button>
    <button id="delete-btn" class="btn btn-outline-danger" title="Delete this prompt">
        <i class="bi bi-trash"></i> Delete
    </button>
</div>
{% endblock %}

{% block content %}
<!-- Hidden element to store prompt ID for JavaScript -->
<span id="prompt-id" class="d-none">{{ prompt_id }}</span>

<div class="container-fluid">
    <div class="row">
        <!-- Main editor column - takes up more space -->
        <div class="col-md-9">
            <div class="card">
                <div class="card-body">
                    <div class="editor-container">
                        <div id="editor-tabs" class="nav nav-tabs">
                            <button class="nav-link active" id="raw-tab" data-bs-toggle="tab" data-bs-target="#raw-content" title="View and edit original content with inclusion references">Raw Content</button>
                            <button class="nav-link" id="expanded-tab" data-bs-toggle="tab" data-bs-target="#expanded-content" title="View content with all inclusions expanded">Expanded Content</button>
                        </div>
                        
                        <div class="tab-content">
                            <div class="tab-pane fade show active" id="raw-content">
                                <div id="editor"></div>
                            </div>
                            <div class="tab-pane fade" id="expanded-content">
                                <div id="preview" class="markdown-preview"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Warnings card remains below the editor -->
            <div class="row mt-3">
                <div class="col-12">
                    <div class="card" id="warnings-card" style="display: none;">
                        <div class="card-header bg-warning text-dark">
                            <h5 class="card-title mb-0">
                                <i class="bi bi-exclamation-triangle-fill me-2"></i>
                                Warnings
                            </h5>
                        </div>
                        <div class="card-body">
                            <div id="warnings">
                                <!-- Warnings will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Sidebar with metadata and references - takes up less space -->
        <div class="col-md-3">
            <!-- Description and Tags card -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5 class="card-title mb-0">Metadata</h5>
                </div>
                <div class="card-body">
                    <div class="mb-2">
                        <div class="d-flex align-items-center">
                            <span class="badge rounded-pill me-2" id="is-composite-badge">Standard</span>
                            <span class="ms-auto small text-muted">Last updated: <span id="last-updated">-</span></span>
                        </div>
                    </div>
                    <div class="mb-2">
                        <span class="small text-muted">Directory: <span id="prompt-directory" class="fw-semibold">-</span></span>
                    </div>
                    <div class="mb-3">
                        <label for="prompt-description" class="form-label">Description</label>
                        <input type="text" class="form-control form-control-sm" id="prompt-description">
                    </div>
                    <div class="mb-3">
                        <label for="prompt-tags" class="form-label">Tags</label>
                        <input type="text" class="form-control form-control-sm" id="prompt-tags" placeholder="tag1, tag2, tag3">
                    </div>
                </div>
            </div>
            
            <!-- Dependencies card -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5 class="card-title mb-0">Dependencies</h5>
                </div>
                <div class="card-body">
                    <div id="dependencies">
                        <p class="text-muted">No dependencies found.</p>
                    </div>
                </div>
            </div>
            
            <!-- Referenced By card -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5 class="card-title mb-0">Referenced By</h5>
                </div>
                <div class="card-body">
                    <div id="referenced-by">
                        <p class="text-muted">Loading references...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Rename Prompt Modal -->
<div class="modal fade" id="renamePromptModal" tabindex="-1" aria-labelledby="renamePromptModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="renamePromptModalLabel">Rename Prompt</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="new-prompt-id" class="form-label">New Name</label>
                    <input type="text" class="form-control" id="new-prompt-id" required>
                    <div class="form-text">Enter a new name for this prompt (no spaces or special characters)</div>
                </div>
                <div class="alert alert-warning" id="rename-warning" style="display: none;">
                    <i class="bi bi-exclamation-triangle-fill me-2"></i>
                    <span id="rename-warning-text"></span>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="confirm-rename-btn">Rename</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Prompt Confirmation Modal -->
<div class="modal fade" id="deletePromptModal" tabindex="-1" aria-labelledby="deletePromptModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deletePromptModalLabel">Confirm Deletion</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this prompt?</p>
                <p class="text-danger">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirm-delete-btn">Delete</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
    /* Make the editor take up maximum vertical space */
    #editor {
        height: calc(85vh - 90px);
        min-height: 600px;
    }
    
    .CodeMirror {
        height: 100%;
        font-size: 14px;
        line-height: 1.6;
    }
    
    /* Style the tabs */
    #editor-tabs .nav-link {
        font-size: 0.9rem;
        padding: 0.5rem 1rem;
    }
    
    /* Fix for expanded content view overflow issue */
    #expanded-content {
        background-color: #fff;
    }
    
    /* Preview styling for expanded view */
    #preview {
        background-color: #fff;
        height: auto !important; /* Force auto height */
        min-height: auto;
        padding: 15px;
        width: 100%;
        overflow: visible; /* Remove scrollbar */
        border: 1px solid #dee2e6;
        border-radius: 4px;
    }
    
    /* Ensure markdown content in preview is properly styled */
    #preview pre {
        background-color: #f8f9fa;
        padding: 10px;
        border-radius: 4px;
        overflow-x: auto;
    }
    
    #preview code {
        background-color: #f8f9fa;
        padding: 2px 4px;
        border-radius: 3px;
        font-family: 'Fira Code', monospace;
    }
    
    /* Make metadata elements smaller and more compact */
    .form-control-sm {
        height: 30px;
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
    }
    
    .card-header {
        padding: 0.5rem 1rem;
    }
    
    .small {
        font-size: 0.875rem;
    }
    
    /* Style the sidebar cards to be more compact */
    .col-md-3 .card {
        font-size: 0.9rem;
    }
    
    .col-md-3 .card-body {
        padding: 0.75rem;
    }
    
    .col-md-3 .form-label {
        margin-bottom: 0.25rem;
        font-weight: 500;
    }
    
    /* Make the list groups in sidebar more compact */
    .col-md-3 .list-group-item {
        padding: 0.5rem 0.75rem;
    }
    
    /* Sticky sidebar */
    @media (min-width: 768px) {
        .col-md-3 {
            position: sticky;
            top: 0;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }
    }
    
    /* Fixed width save button to prevent UI jumps */
    #save-btn {
        min-width: 100px;
    }
    
    /* Style for the autocomplete dropdown */
    .CodeMirror-hints {
        position: absolute;
        z-index: 10;
        overflow: hidden;
        list-style: none;
        margin: 0;
        padding: 0;
        max-height: 20em;
        overflow-y: auto;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    
    .CodeMirror-hint {
        margin: 0;
        padding: 4px 8px;
        white-space: pre;
        cursor: pointer;
        font-size: 0.9em;
    }
    
    .CodeMirror-hint-active {
        background-color: #007bff;
        color: white;
    }
</style>
{% endblock %}

{% block extra_js %}
<script src="/static/js/search-replace.js"></script>
<script>
    // Import utility functions
    // Use the showToast function from utils.js
    
    // Convert markdown to HTML
    function markdownToHtml(markdown) {
        if (!markdown) return '';
        
        // Simple markdown to HTML conversion
        return markdown
            .replace(/\n\n/g, '<br><br>')
            .replace(/\n/g, '<br>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/```([a-z]*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>')
            .replace(/`([^`]+)`/g, '<code>$1</code>')
            .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
            .replace(/^# (.*?)$/gm, '<h1>$1</h1>')
            .replace(/^## (.*?)$/gm, '<h2>$1</h2>')
            .replace(/^### (.*?)$/gm, '<h3>$1</h3>')
            .replace(/^#### (.*?)$/gm, '<h4>$1</h4>')
            .replace(/^##### (.*?)$/gm, '<h5>$1</h5>')
            .replace(/^###### (.*?)$/gm, '<h6>$1</h6>');
    }
    
    // Format date function
    function formatDate(dateString) {
        
        if (!dateString) return 'Unknown';
        try {
            // Try using dayjs if available
            if (window.dayjs) {
                return dayjs(dateString).format('YYYY-MM-DD HH:mm:ss');
            }
            // Fallback to native Date
            const date = new Date(dateString);
            return date.toLocaleString();
        } catch (error) {
            console.error('Error formatting date:', error);
            return dateString;
        }
    }
    
    // Global variables
    let editor;
    let promptId = "{{ prompt_id }}";
    let promptData = null;
    let socket = null;
    let expandedContent = "";
    let dependencies = [];
    let saveTimeout = null;
    let isComposite = false;
    let allPrompts = []; // Store all available prompts for autocomplete
    let searchReplace = null; // Search and replace functionality
    
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize CodeMirror editor
        editor = CodeMirror(document.getElementById('editor'), {
            mode: 'markdown',
            theme: 'default',
            lineNumbers: true,
            lineWrapping: true,
            autofocus: true,
            extraKeys: {
                "Tab": function(cm) {
                    // If autocomplete is active, accept selection
                    if (cm.state.completionActive) {
                        cm.state.completionActive.pick();
                        return;
                    }
                    // Otherwise, insert a tab
                    cm.replaceSelection("    ");
                },
                "Ctrl-Space": function(cm) {
                    cm.showHint({ hint: promptHint });
                },
                "Alt-T": function(cm) {
                    toggleView();
                },
                "Alt-R": function(cm) {
                    if (searchReplace && document.getElementById('raw-tab').classList.contains('active')) {
                        searchReplace.showDialog();
                    }
                }
            }
        });
        
        // Initialize search and replace functionality
        searchReplace = new SearchReplace(editor);
        
        // Setup the custom hint function
        setupPromptCompletion();
        
        // Setup global keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Alt+B for back
            if (e.altKey && e.key === 'b') {
                e.preventDefault();
                window.location.href = '/manage/prompts';
            }
            
            // Alt+T for toggle view (handled in CodeMirror for when editor has focus)
            if (e.altKey && e.key === 't' && !editor.hasFocus()) {
                e.preventDefault();
                toggleView();
            }
            
            // Alt+C for copy content
            if (e.altKey && e.key === 'c') {
                e.preventDefault();
                copyPromptContent();
            }
            
            // Alt+S for save
            if (e.altKey && e.key === 's') {
                e.preventDefault();
                document.getElementById('save-btn').click();
            }
        });
        
        // Load prompt data
        loadPromptData();
        
        // Set up WebSocket connection for real-time editing
        setupWebSocket();
        
        // Set up event handlers
        editor.on('change', handleEditorChange);
        
        document.getElementById('prompt-description').addEventListener('input', handleMetadataChange);
        document.getElementById('prompt-tags').addEventListener('input', handleMetadataChange);
        
        document.getElementById('copy-btn').addEventListener('click', copyPromptContent);
        document.getElementById('toggle-view-btn').addEventListener('click', toggleView);
        document.getElementById('search-replace-btn').addEventListener('click', function() {
            if (searchReplace && document.getElementById('raw-tab').classList.contains('active')) {
                searchReplace.showDialog();
            } else if (!document.getElementById('raw-tab').classList.contains('active')) {
                // If not in raw tab, switch to it first
                document.getElementById('raw-tab').click();
                setTimeout(() => {
                    if (searchReplace) searchReplace.showDialog();
                }, 100);
            }
        });
        document.getElementById('save-btn').addEventListener('click', function() {
            const saveBtn = this;
            const originalContent = saveBtn.innerHTML;
            
            // Change button text to indicate saving (with consistent length)
            saveBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Saving';
            saveBtn.disabled = true;
            
            const content = editor.getValue();
            const description = document.getElementById('prompt-description').value;
            const tagsStr = document.getElementById('prompt-tags').value;
            const tags = tagsStr.split(',').map(tag => tag.trim()).filter(tag => tag);
            
            // First save content
            saveViaApi(content)
                .then(() => {
                    // Then save metadata
                    return saveMetadataViaApi(description, tags);
                })
                .then(() => {
                    // Show "Saved" indication on button
                    saveBtn.innerHTML = '<i class="bi bi-check-circle"></i> Saved ';
                    saveBtn.classList.remove('btn-outline-success');
                    saveBtn.classList.add('btn-success');
                    
                    // Reset button after a delay
                    setTimeout(() => {
                        saveBtn.innerHTML = originalContent;
                        saveBtn.classList.remove('btn-success');
                        saveBtn.classList.add('btn-outline-success');
                        saveBtn.disabled = false;
                    }, 1500);
                })
                .catch(() => {
                    // Reset button on error
                    saveBtn.innerHTML = originalContent;
                    saveBtn.disabled = false;
                });
        });
        document.getElementById('rename-btn').addEventListener('click', showRenamePromptModal);
        document.getElementById('confirm-rename-btn').addEventListener('click', renamePrompt);
        document.getElementById('delete-btn').addEventListener('click', showDeleteConfirmation);
        document.getElementById('confirm-delete-btn').addEventListener('click', deletePrompt);
        
        // Handle tab changes
        document.getElementById('expanded-tab').addEventListener('click', function() {
            // Set background to white for extended content
            document.getElementById('expanded-content').style.backgroundColor = '#ffffff';
            updateExpandedView();
        });
    });
    
    function loadPromptData() {
        fetch(`/api/prompts/${promptId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Prompt not found');
                }
                return response.json();
            })
            .then(data => {
                promptData = data;
                
                // Set editor content
                editor.setValue(data.content);
                
                // Set metadata fields
                document.getElementById('prompt-description').value = data.description || '';
                document.getElementById('prompt-tags').value = data.tags.join(', ');
                document.getElementById('last-updated').textContent = formatDate(data.updated_at);
                document.getElementById('prompt-directory').textContent = data.directory || 'Not specified';
                
                // Set "is composite" badge based on content (composite if it has inclusions)
                const badge = document.getElementById('is-composite-badge');
                
                // Check if the content contains inclusions to determine if it's composite
                isComposite = data.content.includes('[[') && data.content.includes(']]');
                
                if (isComposite) {
                    badge.textContent = 'Composite';
                    badge.classList.add('bg-success');
                } else {
                    badge.textContent = 'Standard';
                    badge.classList.add('bg-secondary');
                }
                
                // If it's a composite prompt, update the expanded view
                if (isComposite) {
                    updateExpandedView();
                }
                
                // Find references to this prompt
                loadReferences();
            })
            .catch(error => {
                console.error('Error loading prompt:', error);
                showToast('Error loading prompt: ' + error.message, 'danger');
            });
    }
    
    function setupWebSocket() {
        try {
            // Create WebSocket connection
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/api/prompts/ws/${promptId}`;
            console.log(`Connecting to WebSocket at: ${wsUrl}`);
            socket = new WebSocket(wsUrl);
        
        // Connection opened
        socket.addEventListener('open', function(event) {
            console.log('WebSocket connection established successfully');
            
            // Request all prompts to build autocomplete list once connected
            loadAllPrompts();
            
            // Send a test message to confirm connection is working
            console.log('Sending test expand message to WebSocket');
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    action: 'expand',
                    content: editor.getValue(),
                    prompt_id: promptId
                }));
            }
        });
        
        // Listen for messages
        socket.addEventListener('message', function(event) {
            console.log('WebSocket message received:', event.data);
            try {
                const data = JSON.parse(event.data);
                
                switch (data.action) {
                    case 'initial':
                        // Initial content already loaded via API
                        console.log('Received initial content');
                        break;
                        
                    case 'update_status':
                        if (data.success) {
                            const lastUpdatedEl = document.getElementById('last-updated');
                            if (lastUpdatedEl) {
                                lastUpdatedEl.textContent = formatDate(data.timestamp);
                            }
                            showToast('Prompt saved', 'success');
                        } else {
                            showToast('Error saving prompt', 'danger');
                        }
                        break;
                        
                    case 'expanded':
                        console.log('Received expanded content:', data);
                        // Store expanded content for preview only - never modify the raw content
                        expandedContent = data.expanded || data.content || '';
                        dependencies = data.dependencies || [];
                        
                        // Update preview only if we're on the expanded tab
                        if (document.getElementById('expanded-tab').classList.contains('active') || 
                            document.getElementById('expanded-content').classList.contains('show', 'active')) {
                            try {
                                console.log('Updating preview with expanded content');
                                document.getElementById('preview').innerHTML = markdownToHtml(expandedContent);
                                
                                // No need to force height - we want it to flow naturally
                                // and use page scrolling instead of inner scrollbar
                                const previewElement = document.getElementById('preview');
                                previewElement.style.height = 'auto';
                            } catch (error) {
                                console.error('Error rendering expanded content:', error);
                                document.getElementById('preview').innerHTML = '<div class="alert alert-danger">Error rendering expanded content. See console for details.</div>';
                            }
                        }
                        
                        // Update dependencies list
                        updateDependenciesList();
                        
                        // Show warnings if any
                        if (data.warnings && data.warnings.length > 0) {
                            showWarnings(data.warnings);
                        } else {
                            hideWarnings();
                        }
                        break;
                        
                    default:
                        console.log('Unknown action received:', data.action);
                }
            } catch (error) {
                console.error('Error processing WebSocket message:', error);
            }
        });
        
        // Connection closed
        socket.addEventListener('close', function(event) {
            console.log(`WebSocket connection closed with code ${event.code}, reason: ${event.reason}`);
            
            // Try to reconnect after a delay
            setTimeout(() => {
                console.log('Attempting to reconnect...');
                setupWebSocket();
            }, 2000);
        });
        
        // Connection error
        socket.addEventListener('error', function(event) {
            console.error('WebSocket error:', event);
            console.error('Error details:', JSON.stringify(event, Object.getOwnPropertyNames(event)));
            showToast('WebSocket connection error. Falling back to API.', 'warning');
            
            // Force immediate use of API fallback
            if (document.getElementById('expanded-tab').classList.contains('active') || 
                document.getElementById('expanded-content').classList.contains('show', 'active')) {
                useFallbackApi();
            }
        });
        } catch (error) {
            console.error('Error setting up WebSocket:', error);
            showToast('WebSocket setup error: ' + error.message, 'danger');
        }
    }
    
    // Function to use the API fallback for expansion
    function useFallbackApi() {
        const content = editor.getValue();
        console.log('Using API fallback with content:', content);
        
        fetch('/api/prompts/expand', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: content,
                prompt_id: promptId
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Expansion API response:', data);
            expandedContent = data.expanded || data.content;
            dependencies = data.dependencies || [];
            
            // Update preview
            try {
                console.log('Updating preview with expanded content from API');
                document.getElementById('preview').innerHTML = markdownToHtml(expandedContent);
                
                // No need to force height - we want it to flow naturally
                // and use page scrolling instead of inner scrollbar
                const previewElement = document.getElementById('preview');
                previewElement.style.height = 'auto';
            } catch (error) {
                console.error('Error rendering expanded content:', error);
                document.getElementById('preview').innerHTML = '<div class="alert alert-danger">Error rendering expanded content. See console for details.</div>';
            }
            
            // Update dependencies list
            updateDependenciesList();
            
            // Show warnings if any
            if (data.warnings && data.warnings.length > 0) {
                showWarnings(data.warnings);
            } else {
                hideWarnings();
            }
        })
        .catch(error => {
            console.error('Error with API fallback:', error);
            showToast('Error expanding content: ' + error.message, 'danger');
            document.getElementById('preview').innerHTML = '<div class="alert alert-danger">Error expanding content. API fallback failed.</div>';
        });
    }
    
    function handleEditorChange() {
        // Clear previous timeout
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
        
        // Set new timeout for autosave (debounce)
        saveTimeout = setTimeout(() => {
            const content = editor.getValue();
            
            // Update the composite status
            isComposite = content.includes('[[') && content.includes(']]');
            const badge = document.getElementById('is-composite-badge');
            
            // Clear existing classes
            badge.classList.remove('bg-success', 'bg-secondary');
            
            // Set new badge
            if (isComposite) {
                badge.textContent = 'Composite';
                badge.classList.add('bg-success');
            } else {
                badge.textContent = 'Standard';
                badge.classList.add('bg-secondary');
            }
            
            // Always save via API for reliable saving
            const saveBtn = document.getElementById('save-btn');
            const originalContent = saveBtn.innerHTML;
            
            // Temporarily change button appearance to show "Saving..." in a subtle way
            saveBtn.classList.remove('btn-outline-success');
            saveBtn.classList.add('btn-success');
            
            saveViaApi(content)
                .then(() => {
                    // Show "Saved" indication on button
                    saveBtn.innerHTML = '<i class="bi bi-check-circle"></i> Saved';
                    
                    // Reset button after a delay
                    setTimeout(() => {
                        saveBtn.innerHTML = originalContent;
                        saveBtn.classList.remove('btn-success');
                        saveBtn.classList.add('btn-outline-success');
                    }, 1500);
                })
                .catch(() => {
                    // Reset button on error
                    saveBtn.innerHTML = originalContent;
                    saveBtn.classList.remove('btn-success');
                    saveBtn.classList.add('btn-outline-success');
                });
            
            // Also update expansion preview if this is a composite prompt
            if (isComposite && document.getElementById('expanded-tab').classList.contains('active')) {
                updateExpandedView();
            }
            
        }, 1000); // 1 second debounce
    }
    
    // Function to save via API when WebSocket is not available
    function saveViaApi(content) {
        // No longer show a toast for saving - we'll indicate this on the button
        
        return fetch(`/api/prompts/${promptId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: content
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Save API response:', data);
            
            // Update last updated timestamp if available
            if (data.updated_at) {
                const lastUpdatedEl = document.getElementById('last-updated');
                if (lastUpdatedEl) {
                    lastUpdatedEl.textContent = formatDate(data.updated_at);
                }
            }
            
            // If this is a composite prompt, update the expanded view
            if (isComposite) {
                if (document.getElementById('expanded-tab').classList.contains('active') || 
                    document.getElementById('expanded-content').classList.contains('show', 'active')) {
                    useFallbackApi();
                }
            }
            
            return data;
        })
        .catch(error => {
            console.error('Error saving via API:', error);
            showToast('Error saving prompt: ' + error.message, 'danger');
            throw error; // Re-throw to allow promise chaining
        });
    }
    
    function handleMetadataChange() {
        // Clear previous timeout
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
        
        // Set new timeout for autosave (debounce)
        saveTimeout = setTimeout(() => {
            const description = document.getElementById('prompt-description').value;
            const tagsStr = document.getElementById('prompt-tags').value;
            const tags = tagsStr.split(',').map(tag => tag.trim()).filter(tag => tag);
            
            // Try to send update via WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                try {
                    socket.send(JSON.stringify({
                        action: 'update_metadata',
                        description: description,
                        tags: tags
                    }));
                } catch (error) {
                    console.error('Error sending WebSocket message for metadata:', error);
                    // Fall back to API save
                    saveMetadataViaApi(description, tags);
                }
            } else {
                // WebSocket not available, use API fallback
                console.log('WebSocket not available for metadata save, using API fallback');
                saveMetadataViaApi(description, tags);
            }
        }, 1000); // 1 second debounce
    }
    
    // Function to save metadata via API when WebSocket is not available
    function saveMetadataViaApi(description, tags) {
        // No longer show a toast for saving - we'll indicate this on the button
        
        return fetch(`/api/prompts/${promptId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                description: description,
                tags: tags
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Save metadata API response:', data);
            
            // Update last updated timestamp if available
            if (data.updated_at) {
                const lastUpdatedEl = document.getElementById('last-updated');
                if (lastUpdatedEl) {
                    lastUpdatedEl.textContent = formatDate(data.updated_at);
                }
            }
            
            return data;
        })
        .catch(error => {
            console.error('Error saving metadata via API:', error);
            showToast('Error saving metadata: ' + error.message, 'danger');
            throw error; // Re-throw to allow promise chaining
        });
    }
    
    function updateExpandedView() {
        console.log('Updating expanded view');
        
        // Get current content
        const content = editor.getValue();
        console.log('Current editor content:', content);
        
        // Ensure the expanded content tab has white background extending fully
        const expandedContentElement = document.getElementById('expanded-content');
        expandedContentElement.style.backgroundColor = '#ffffff';
        
        // Always use API fallback which is more reliable
        useFallbackApi();
    }
    
    function updateDependenciesList() {
        const dependenciesContainer = document.getElementById('dependencies');
        
        if (dependencies.length === 0) {
            dependenciesContainer.innerHTML = '<p class="text-muted">No dependencies found.</p>';
            return;
        }
        
        let html = '<ul class="list-group list-group-flush">';
        
        dependencies.forEach(dep => {
            html += `
                <li class="list-group-item py-1 px-2">
                    <a href="/prompts/${dep}">${dep}</a>
                </li>
            `;
        });
        
        html += '</ul>';
        
        dependenciesContainer.innerHTML = html;
    }
    
    function loadReferences() {
        // Find all prompts that reference this one
        fetch('/api/prompts/all')
            .then(response => response.json())
            .then(prompts => {
                // Filter prompts that might reference this one
                const references = prompts.filter(p => 
                    p.content.includes(`[[${promptId}]]`) ||
                    p.content.includes(`[[${promptId}.md]]`)
                );
                
                const referencedByContainer = document.getElementById('referenced-by');
                
                if (references.length === 0) {
                    referencedByContainer.innerHTML = '<p class="text-muted">No references found.</p>';
                    return;
                }
                
                let html = '<ul class="list-group list-group-flush">';
                
                references.forEach(ref => {
                    // Check if the prompt is composite
                    const isComposite = ref.content.includes('[[') && ref.content.includes(']]');
                    
                    html += `
                        <li class="list-group-item py-1 px-2">
                            <div>
                                <a href="/prompts/${ref.id}">${ref.id}</a>
                                ${ref.description ? `<small class="text-muted d-block">${ref.description}</small>` : ''}
                            </div>
                            <span class="badge ${isComposite ? 'bg-success' : 'bg-secondary'} rounded-pill">
                                ${isComposite ? 'Composite' : 'Standard'}
                            </span>
                        </li>
                    `;
                });
                
                html += '</ul>';
                
                referencedByContainer.innerHTML = html;
            })
            .catch(error => {
                console.error('Error loading references:', error);
                document.getElementById('referenced-by').innerHTML = '<p class="text-danger">Error loading references.</p>';
            });
    }
    
    function copyPromptContent() {
        // When Alt+C is pressed, we should copy the expanded content
        // If we don't have expanded content yet, let's get it
        if (!expandedContent && editor.getValue().includes('[[')) {
            // We need to ensure we have the expanded content before copying
            const rawContent = editor.getValue();
            
            // Make a quick API call to get the expanded content
            fetch('/api/prompts/expand', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    content: rawContent,
                    prompt_id: promptId
                })
            })
            .then(response => response.json())
            .then(data => {
                expandedContent = data.expanded;
                copyToClipboard(expandedContent);
            })
            .catch(error => {
                console.error('Error expanding content for copy:', error);
                // Fall back to raw content if expansion fails
                copyToClipboard(rawContent);
            });
        } else {
            // Either we have expanded content already, or this is not a composite prompt
            const contentToCopy = expandedContent || editor.getValue();
            copyToClipboard(contentToCopy);
        }
    }
    
    function copyToClipboard(content) {
        // Copy to clipboard
        navigator.clipboard.writeText(content)
            .then(() => {
                showToast('Copied to clipboard');
            })
            .catch(error => {
                console.error('Error copying to clipboard:', error);
                showToast('Error copying to clipboard', 'danger');
                
                // Fallback method for browsers that don't support clipboard API
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = content;
                    textarea.style.position = 'fixed';  // Avoid scrolling to bottom
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showToast('Copied to clipboard (fallback method)');
                } catch (fallbackError) {
                    console.error('Fallback copy failed:', fallbackError);
                    showToast('Could not copy to clipboard', 'danger');
                }
            });
    }
    
    function toggleView() {
        // Toggle between raw and expanded view
        const rawTab = document.getElementById('raw-tab');
        const expandedTab = document.getElementById('expanded-tab');
        
        if (rawTab.classList.contains('active')) {
            rawTab.classList.remove('active');
            document.getElementById('raw-content').classList.remove('show', 'active');
            
            expandedTab.classList.add('active');
            document.getElementById('expanded-content').classList.add('show', 'active');
            
            // Update expanded view
            updateExpandedView();
        } else {
            expandedTab.classList.remove('active');
            document.getElementById('expanded-content').classList.remove('show', 'active');
            
            rawTab.classList.add('active');
            document.getElementById('raw-content').classList.add('show', 'active');
        }
    }
    
    function showRenamePromptModal() {
        // Pre-fill with current prompt ID
        document.getElementById('new-prompt-id').value = promptId;
        
        // Show the modal
        const renameModal = new bootstrap.Modal(document.getElementById('renamePromptModal'));
        renameModal.show();
        
        // Focus the input field
        setTimeout(() => {
            document.getElementById('new-prompt-id').focus();
            document.getElementById('new-prompt-id').select();
        }, 300);
        
        // Clear any previous warnings
        document.getElementById('rename-warning').style.display = 'none';
    }
    
    function renamePrompt() {
        const newPromptId = document.getElementById('new-prompt-id').value.trim();
        
        // Validate
        if (!newPromptId) {
            document.getElementById('rename-warning-text').textContent = 'Prompt name cannot be empty';
            document.getElementById('rename-warning').style.display = 'block';
            return;
        }
        
        if (newPromptId === promptId) {
            // No change, just close the modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('renamePromptModal'));
            modal.hide();
            return;
        }
        
        // Check if a prompt with this name already exists
        fetch(`/api/prompts/check_exists/${newPromptId}`)
            .then(response => response.json())
            .then(data => {
                if (data.exists) {
                    // Show warning
                    document.getElementById('rename-warning-text').textContent = 
                        `A prompt with the name "${newPromptId}" already exists. Please choose a different name.`;
                    document.getElementById('rename-warning').style.display = 'block';
                    return;
                }
                
                // Proceed with rename
                performRename(newPromptId);
            })
            .catch(error => {
                console.error('Error checking prompt existence:', error);
                // If we can't check, try anyway but tell the user there might be a risk
                document.getElementById('rename-warning-text').textContent = 
                    'Could not verify if this name is available. Proceeding might overwrite an existing prompt.';
                document.getElementById('rename-warning').style.display = 'block';
                
                // Add a button to force rename
                const warningEl = document.getElementById('rename-warning');
                const forceButton = document.createElement('button');
                forceButton.className = 'btn btn-sm btn-warning mt-2';
                forceButton.textContent = 'Rename Anyway';
                forceButton.addEventListener('click', () => performRename(newPromptId));
                warningEl.appendChild(forceButton);
            });
    }
    
    function performRename(newPromptId) {
        // Show saving indicator on the rename button
        const renameBtn = document.getElementById('confirm-rename-btn');
        const originalBtnText = renameBtn.textContent;
        renameBtn.textContent = 'Renaming...';
        renameBtn.disabled = true;
        
        // Prepare data for rename
        const renameData = {
            old_id: promptId,
            new_id: newPromptId,
            // Include the current content and metadata to ensure nothing is lost
            content: editor.getValue(),
            description: document.getElementById('prompt-description').value,
            tags: document.getElementById('prompt-tags').value.split(',').map(tag => tag.trim()).filter(tag => tag)
        };
        
        // Send rename request
        fetch('/api/prompts/rename', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(renameData)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to rename prompt: ${response.status} ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('renamePromptModal'));
            modal.hide();
            
            // Show success toast
            showToast('Prompt renamed successfully', 'success');
            
            // Redirect to the new prompt URL
            window.location.href = `/prompts/${newPromptId}`;
        })
        .catch(error => {
            console.error('Error renaming prompt:', error);
            // Reset button
            renameBtn.textContent = originalBtnText;
            renameBtn.disabled = false;
            
            // Show error
            document.getElementById('rename-warning-text').textContent = 
                `Error renaming prompt: ${error.message}`;
            document.getElementById('rename-warning').style.display = 'block';
        });
    }
    
    function showDeleteConfirmation() {
        const deleteModal = new bootstrap.Modal(document.getElementById('deletePromptModal'));
        deleteModal.show();
    }
    
    function deletePrompt() {
        // Send DELETE request
        fetch(`/api/prompts/${promptId}`, {
            method: 'DELETE'
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to delete prompt');
            }
            return response.json();
        })
        .then(data => {
            // Success - redirect to prompts list
            showToast('Prompt deleted successfully');
            
            // Redirect after a short delay
            setTimeout(() => {
                window.location.href = '/manage/prompts';
            }, 1000);
        })
        .catch(error => {
            console.error('Error deleting prompt:', error);
            showToast('Error deleting prompt: ' + error.message, 'danger');
        });
    }
    
    function showWarnings(warnings) {
        const warningsCard = document.getElementById('warnings-card');
        const warningsContainer = document.getElementById('warnings');
        
        // Create warning message HTML
        let html = '<ul class="list-group">';
        
        warnings.forEach(warning => {
            html += `
                <li class="list-group-item list-group-item-warning">
                    <i class="bi bi-exclamation-triangle-fill me-2"></i>
                    ${warning}
                </li>
            `;
        });
        
        html += '</ul>';
        
        // Update warnings container and show card
        warningsContainer.innerHTML = html;
        warningsCard.style.display = 'block';
    }
    
    function hideWarnings() {
        const warningsCard = document.getElementById('warnings-card');
        warningsCard.style.display = 'none';
    }
    
    // Load all prompts for autocomplete
    function loadAllPrompts() {
        fetch('/api/prompts/all')
            .then(response => response.json())
            .then(prompts => {
                // Store the prompts for autocomplete
                allPrompts = prompts.map(p => p.id);
                console.log(`Loaded ${allPrompts.length} prompts for autocomplete`);
            })
            .catch(error => {
                console.error('Error loading prompts for autocomplete:', error);
            });
    }
    
    // Set up the prompt completion functionality
    function setupPromptCompletion() {
        // Add custom helper for CodeMirror hints
        if (!CodeMirror.helpers) {
            CodeMirror.helpers = {};
        }
        
        // Override the default hint keymap to fix arrow key selection issues
        const customKeys = {
            // Preserve the selection when moving up/down
            Up: function(cm, handle) {
                handle.moveFocus(-1);
                return true; // Handled
            },
            Down: function(cm, handle) {
                handle.moveFocus(1);
                return true; // Handled
            },
            PageUp: function(cm, handle) {
                handle.moveFocus(-handle.menuSize() + 1, true);
                return true;
            },
            PageDown: function(cm, handle) {
                handle.moveFocus(handle.menuSize() - 1, true);
                return true;
            },
            Home: function(cm, handle) {
                handle.setFocus(0);
                return true;
            },
            End: function(cm, handle) {
                handle.setFocus(handle.length - 1);
                return true;
            },
            Enter: function(cm, handle) {
                if (handle.selectedHint >= 0) {
                    handle.pick();
                } else {
                    cm.replaceSelection("\n");
                }
                return true;
            },
            Tab: function(cm, handle) {
                if (handle.selectedHint >= 0) {
                    handle.pick();
                } else {
                    cm.replaceSelection("\t");
                }
                return true;
            },
            Esc: function(cm, handle) {
                handle.close();
                return true;
            }
        };
        
        // Define our custom hint function
        window.promptHint = function(editor, options) {
            const cursor = editor.getCursor();
            const line = editor.getLine(cursor.line);
            const lineBeforeCursor = line.substring(0, cursor.ch);
            
            // Check if we're typing after [[ 
            const match = lineBeforeCursor.match(/\[\[([^\]]*?)$/);
            if (!match) return null;
            
            const prefix = match[1]; // The text after [[ but before cursor
            
            // Filter prompts based on prefix
            const filteredPrompts = allPrompts.filter(prompt => 
                prompt.toLowerCase().includes(prefix.toLowerCase())
            );
            
            if (filteredPrompts.length === 0) return null;
            
            // Return the hint object with options that fix arrow key behavior
            return {
                list: filteredPrompts.map(prompt => ({ 
                    text: prompt + "]]", 
                    displayText: prompt 
                })),
                from: { line: cursor.line, ch: cursor.ch - prefix.length },
                to: cursor,
                selectedHint: 0 // Start with the first suggestion selected
            };
        };
        
        // Listen for [[ key sequence to trigger autocomplete
        editor.on('keyup', function(cm, event) {
            const cursor = cm.getCursor();
            const line = cm.getLine(cursor.line);
            const lineBeforeCursor = line.substring(0, cursor.ch);
            
            // Check if we just typed [[ or are within a [[ ]] pair
            if (lineBeforeCursor.endsWith('[[') || lineBeforeCursor.match(/\[\[([^\]]*?)$/)) {
                cm.showHint({ 
                    hint: promptHint,
                    completeSingle: false,
                    closeOnUnfocus: false,
                    customKeys: customKeys
                });
            }
        });
    }
</script>
{% endblock %}
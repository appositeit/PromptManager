{% extends "base.html" %}

{% block title %}Prompt Editor{% endblock %}

{% block extra_js_head %}
<script src="{{ url_for('static', path='js/utils.js') }}"></script>
{% endblock %}

{% block header_title %}{{ prompt_id }}{% endblock %}

{% block header_actions %}
<div class="btn-group me-2">
    <a href="/manage/prompts" class="btn btn-outline-secondary" id="back-btn" title="Back to Prompt List (Alt+B)">
        <i class="bi bi-arrow-left"></i> Back to List
    </a>
</div>
<div class="btn-group">
    <button id="copy-btn" class="btn btn-outline-primary" title="Copy content to clipboard (Alt+C)">
        <i class="bi bi-clipboard"></i> Copy
    </button>
    <button id="toggle-view-btn" class="btn btn-outline-primary" title="Toggle between raw and expanded view (Alt+T)">
        <i class="bi bi-eye"></i> Toggle View
    </button>
    <button id="delete-btn" class="btn btn-outline-danger" title="Delete this prompt">
        <i class="bi bi-trash"></i> Delete
    </button>
</div>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="mb-3">
                        <div class="d-flex align-items-center mb-2">
                            <span class="badge rounded-pill me-2" id="prompt-type-badge">Standard</span>
                            <span id="prompt-id" class="fw-bold">{{ prompt_id }}</span>
                            <span class="ms-auto small text-muted">Last updated: <span id="last-updated">-</span></span>
                        </div>
                        
                        <div class="row g-2 mb-3">
                            <div class="col-md-6">
                                <label for="prompt-description" class="form-label">Description</label>
                                <input type="text" class="form-control form-control-sm" id="prompt-description">
                            </div>
                            <div class="col-md-6">
                                <label for="prompt-tags" class="form-label">Tags</label>
                                <input type="text" class="form-control form-control-sm" id="prompt-tags" placeholder="tag1, tag2, tag3">
                            </div>
                        </div>
                    </div>
                    
                    <div class="editor-container">
                        <div id="editor-tabs" class="nav nav-tabs">
                            <button class="nav-link active" id="raw-tab" data-bs-toggle="tab" data-bs-target="#raw-content" title="View and edit original content with inclusion references">Raw Content</button>
                            <button class="nav-link" id="expanded-tab" data-bs-toggle="tab" data-bs-target="#expanded-content" title="View content with all inclusions expanded">Expanded Content</button>
                        </div>
                        <style>
                            #editor, #preview {
                                height: calc(80vh - 150px);
                                min-height: 500px;
                            }
                            .CodeMirror {
                                height: 100%;
                                font-size: 14px;
                                line-height: 1.6;
                            }
                            /* Style the tabs */
                            #editor-tabs .nav-link {
                                font-size: 0.9rem;
                                padding: 0.5rem 1rem;
                            }
                            /* Make metadata elements smaller and more compact */
                            .form-control-sm {
                                height: 30px;
                                padding: 0.25rem 0.5rem;
                                font-size: 0.875rem;
                            }
                            .card-header {
                                padding: 0.5rem 1rem;
                            }
                            .small {
                                font-size: 0.875rem;
                            }
                        </style>
                        
                        <div class="tab-content">
                            <div class="tab-pane fade show active" id="raw-content">
                                <div id="editor"></div>
                            </div>
                            <div class="tab-pane fade" id="expanded-content">
                                <div id="preview" class="markdown-preview"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="row mt-4">
        <div class="col-md-4">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">Dependencies</h5>
                </div>
                <div class="card-body">
                    <div id="dependencies">
                        <p class="text-muted">No dependencies found.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">Referenced By</h5>
                </div>
                <div class="card-body">
                    <div id="referenced-by">
                        <p class="text-muted">Loading references...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="row mt-4">
        <div class="col-12">
            <div class="card" id="warnings-card" style="display: none;">
                <div class="card-header bg-warning text-dark">
                    <h5 class="card-title mb-0">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        Warnings
                    </h5>
                </div>
                <div class="card-body">
                    <div id="warnings">
                        <!-- Warnings will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Delete Prompt Confirmation Modal -->
<div class="modal fade" id="deletePromptModal" tabindex="-1" aria-labelledby="deletePromptModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deletePromptModalLabel">Confirm Deletion</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this prompt?</p>
                <p class="text-danger">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirm-delete-btn">Delete</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // Import utility functions
    // Use the showToast function from utils.js
    
    // Convert markdown to HTML
    function markdownToHtml(markdown) {
        if (!markdown) return '';
        
        // Simple markdown to HTML conversion
        return markdown
            .replace(/\n\n/g, '<br><br>')
            .replace(/\n/g, '<br>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/```([a-z]*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>')
            .replace(/`([^`]+)`/g, '<code>$1</code>')
            .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
            .replace(/^# (.*?)$/gm, '<h1>$1</h1>')
            .replace(/^## (.*?)$/gm, '<h2>$1</h2>')
            .replace(/^### (.*?)$/gm, '<h3>$1</h3>')
            .replace(/^#### (.*?)$/gm, '<h4>$1</h4>')
            .replace(/^##### (.*?)$/gm, '<h5>$1</h5>')
            .replace(/^###### (.*?)$/gm, '<h6>$1</h6>');
    }
    
    // Format date function
    function formatDate(dateString) {
        
        if (!dateString) return 'Unknown';
        try {
            // Try using dayjs if available
            if (window.dayjs) {
                return dayjs(dateString).format('YYYY-MM-DD HH:mm:ss');
            }
            // Fallback to native Date
            const date = new Date(dateString);
            return date.toLocaleString();
        } catch (error) {
            console.error('Error formatting date:', error);
            return dateString;
        }
    }
    
    // Global variables
    let editor;
    let promptId = "{{ prompt_id }}";
    let promptData = null;
    let socket = null;
    let expandedContent = "";
    let dependencies = [];
    let saveTimeout = null;
    let isComposite = false;
    let allPrompts = []; // Store all available prompts for autocomplete
    
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize CodeMirror editor
        editor = CodeMirror(document.getElementById('editor'), {
            mode: 'markdown',
            theme: 'default',
            lineNumbers: true,
            lineWrapping: true,
            autofocus: true,
            extraKeys: {
                "Tab": function(cm) {
                    // If autocomplete is active, accept selection
                    if (cm.state.completionActive) {
                        cm.state.completionActive.pick();
                        return;
                    }
                    // Otherwise, insert a tab
                    cm.replaceSelection("    ");
                },
                "Ctrl-Space": function(cm) {
                    cm.showHint({ hint: promptHint });
                },
                "Alt-T": function(cm) {
                    toggleView();
                }
            }
        });
        
        // Setup the custom hint function
        setupPromptCompletion();
        
        // Setup global keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Alt+B for back
            if (e.altKey && e.key === 'b') {
                e.preventDefault();
                window.location.href = '/manage/prompts';
            }
            
            // Alt+T for toggle view (handled in CodeMirror for when editor has focus)
            if (e.altKey && e.key === 't' && !editor.hasFocus()) {
                e.preventDefault();
                toggleView();
            }
            
            // Alt+C for copy content
            if (e.altKey && e.key === 'c') {
                e.preventDefault();
                copyPromptContent();
            }
        });
        
        // Load prompt data
        loadPromptData();
        
        // Set up WebSocket connection for real-time editing
        setupWebSocket();
        
        // Set up event handlers
        editor.on('change', handleEditorChange);
        
        document.getElementById('prompt-description').addEventListener('input', handleMetadataChange);
        document.getElementById('prompt-tags').addEventListener('input', handleMetadataChange);
        
        document.getElementById('copy-btn').addEventListener('click', copyPromptContent);
        document.getElementById('toggle-view-btn').addEventListener('click', toggleView);
        document.getElementById('delete-btn').addEventListener('click', showDeleteConfirmation);
        document.getElementById('confirm-delete-btn').addEventListener('click', deletePrompt);
        
        // Handle tab changes
        document.getElementById('expanded-tab').addEventListener('click', updateExpandedView);
    });
    
    function loadPromptData() {
        fetch(`/api/prompts/${promptId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Prompt not found');
                }
                return response.json();
            })
            .then(data => {
                promptData = data;
                
                // Set editor content
                editor.setValue(data.content);
                
                // Set metadata fields
                document.getElementById('prompt-description').value = data.description || '';
                document.getElementById('prompt-tags').value = data.tags.join(', ');
                document.getElementById('last-updated').textContent = formatDate(data.updated_at);
                
                // Set prompt type badge
                const badge = document.getElementById('prompt-type-badge');
                badge.textContent = data.prompt_type.charAt(0).toUpperCase() + data.prompt_type.slice(1);
                
                // Set badge color based on type
                if (data.prompt_type === 'composite') {
                    badge.classList.add('bg-success');
                    isComposite = true;
                } else if (data.prompt_type === 'system') {
                    badge.classList.add('bg-primary');
                } else if (data.prompt_type === 'user') {
                    badge.classList.add('bg-info');
                } else {
                    badge.classList.add('bg-secondary');
                }
                
                // If it's a composite prompt, update the expanded view
                if (isComposite) {
                    updateExpandedView();
                }
                
                // Find references to this prompt
                loadReferences();
            })
            .catch(error => {
                console.error('Error loading prompt:', error);
                showToast('Error loading prompt: ' + error.message, 'danger');
            });
    }
    
    function setupWebSocket() {
        // Create WebSocket connection
        const wsUrl = `ws://${window.location.host}/api/prompts/ws/${promptId}`;
        console.log(`Connecting to WebSocket at: ${wsUrl}`);
        socket = new WebSocket(wsUrl);
        
        // Connection opened
        socket.addEventListener('open', function(event) {
            console.log('WebSocket connection established successfully');
            
            // Request all prompts to build autocomplete list once connected
            loadAllPrompts();
            
            // Send a test message to confirm connection is working
            console.log('Sending test expand message to WebSocket');
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    action: 'expand',
                    content: editor.getValue(),
                    prompt_id: promptId
                }));
            }
        });
        
        // Listen for messages
        socket.addEventListener('message', function(event) {
            console.log('WebSocket message received:', event.data);
            try {
                const data = JSON.parse(event.data);
                
                switch (data.action) {
                    case 'initial':
                        // Initial content already loaded via API
                        console.log('Received initial content');
                        break;
                        
                    case 'update_status':
                        if (data.success) {
                            const lastUpdatedEl = document.getElementById('last-updated');
                            if (lastUpdatedEl) {
                                lastUpdatedEl.textContent = formatDate(data.timestamp);
                            }
                            showToast('Prompt saved', 'success');
                        } else {
                            showToast('Error saving prompt', 'danger');
                        }
                        break;
                        
                    case 'expanded':
                        console.log('Received expanded content:', data);
                        // Store expanded content for preview only - never modify the raw content
                        expandedContent = data.expanded || data.content || '';
                        dependencies = data.dependencies || [];
                        
                        // Update preview only if we're on the expanded tab
                        if (document.getElementById('expanded-tab').classList.contains('active') || 
                            document.getElementById('expanded-content').classList.contains('show', 'active')) {
                            try {
                                console.log('Updating preview with expanded content');
                                document.getElementById('preview').innerHTML = markdownToHtml(expandedContent);
                            } catch (error) {
                                console.error('Error rendering expanded content:', error);
                                document.getElementById('preview').innerHTML = '<div class="alert alert-danger">Error rendering expanded content. See console for details.</div>';
                            }
                        }
                        
                        // Update dependencies list
                        updateDependenciesList();
                        
                        // Show warnings if any
                        if (data.warnings && data.warnings.length > 0) {
                            showWarnings(data.warnings);
                        } else {
                            hideWarnings();
                        }
                        break;
                        
                    default:
                        console.log('Unknown action received:', data.action);
                }
            } catch (error) {
                console.error('Error processing WebSocket message:', error);
            }
        });
        
        // Connection closed
        socket.addEventListener('close', function(event) {
            console.log(`WebSocket connection closed with code ${event.code}, reason: ${event.reason}`);
            
            // Try to reconnect after a delay
            setTimeout(() => {
                console.log('Attempting to reconnect...');
                setupWebSocket();
            }, 2000);
        });
        
        // Connection error
        socket.addEventListener('error', function(event) {
            console.error('WebSocket error:', event);
            showToast('WebSocket connection error. Check console for details.', 'danger');
        });
    }
    
    function handleEditorChange() {
        // Clear previous timeout
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
        
        // Set new timeout for autosave (debounce)
        saveTimeout = setTimeout(() => {
            const content = editor.getValue();
            
            // Send update via WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    action: 'update',
                    content: content
                }));
                
                // If this is a composite prompt or if the content contains inclusion markers,
                // also request expansion for preview purposes
                if (isComposite || content.includes('[[')) {
                    socket.send(JSON.stringify({
                        action: 'expand',
                        content: content,
                        prompt_id: promptId
                    }));
                }
            }
        }, 1000); // 1 second debounce
    }
    
    function handleMetadataChange() {
        // Clear previous timeout
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
        
        // Set new timeout for autosave (debounce)
        saveTimeout = setTimeout(() => {
            const description = document.getElementById('prompt-description').value;
            const tagsStr = document.getElementById('prompt-tags').value;
            const tags = tagsStr.split(',').map(tag => tag.trim()).filter(tag => tag);
            
            // Send update via WebSocket
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    action: 'update_metadata',
                    description: description,
                    tags: tags
                }));
            }
        }, 1000); // 1 second debounce
    }
    
    function updateExpandedView() {
        console.log('Updating expanded view');
        
        // Get current content
        const content = editor.getValue();
        console.log('Current editor content:', content);
        
        // Send expansion request via WebSocket
        if (socket && socket.readyState === WebSocket.OPEN) {
            console.log('Sending expansion request via WebSocket');
            socket.send(JSON.stringify({
                action: 'expand',
                content: content,
                prompt_id: promptId
            }));
        } else {
            console.log('WebSocket not available, using API fallback');
            // Fallback to API if WebSocket is not available
            showToast('Using API fallback for expansion', 'info');
            
            fetch('/api/prompts/expand', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    content: content
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Expansion API response:', data);
                expandedContent = data.expanded || data.content;
                dependencies = data.dependencies || [];
                
                // Update preview
                try {
                    console.log('Updating preview with expanded content from API');
                    document.getElementById('preview').innerHTML = markdownToHtml(expandedContent);
                } catch (error) {
                    console.error('Error rendering expanded content:', error);
                    document.getElementById('preview').innerHTML = '<div class="alert alert-danger">Error rendering expanded content. See console for details.</div>';
                }
                
                // Update dependencies list
                updateDependenciesList();
                
                // Show warnings if any
                if (data.warnings && data.warnings.length > 0) {
                    showWarnings(data.warnings);
                } else {
                    hideWarnings();
                }
            })
            .catch(error => {
                console.error('Error expanding content:', error);
                showToast('Error expanding content: ' + error.message, 'danger');
            });
        }
    }
    
    function updateDependenciesList() {
        const dependenciesContainer = document.getElementById('dependencies');
        
        if (dependencies.length === 0) {
            dependenciesContainer.innerHTML = '<p class="text-muted">No dependencies found.</p>';
            return;
        }
        
        let html = '<ul class="list-group">';
        
        dependencies.forEach(dep => {
            html += `
                <li class="list-group-item d-flex justify-content-between align-items-center">
                    <a href="/prompts/${dep}">${dep}</a>
                </li>
            `;
        });
        
        html += '</ul>';
        
        dependenciesContainer.innerHTML = html;
    }
    
    function loadReferences() {
        // Find all prompts that reference this one
        fetch('/api/prompts/all')
            .then(response => response.json())
            .then(prompts => {
                // Filter prompts that might reference this one
                const references = prompts.filter(p => 
                    p.prompt_type === 'composite' && 
                    p.content.includes(`[[${promptId}]]`) ||
                    p.content.includes(`[[${promptId}.md]]`)
                );
                
                const referencedByContainer = document.getElementById('referenced-by');
                
                if (references.length === 0) {
                    referencedByContainer.innerHTML = '<p class="text-muted">No references found.</p>';
                    return;
                }
                
                let html = '<ul class="list-group">';
                
                references.forEach(ref => {
                    html += `
                        <li class="list-group-item d-flex justify-content-between align-items-center">
                            <div>
                                <a href="/prompts/${ref.id}">${ref.id}</a>
                                ${ref.description ? `<small class="text-muted d-block">${ref.description}</small>` : ''}
                            </div>
                            <span class="badge bg-${ref.prompt_type === 'composite' ? 'success' : 'secondary'} rounded-pill">
                                ${ref.prompt_type}
                            </span>
                        </li>
                    `;
                });
                
                html += '</ul>';
                
                referencedByContainer.innerHTML = html;
            })
            .catch(error => {
                console.error('Error loading references:', error);
                document.getElementById('referenced-by').innerHTML = '<p class="text-danger">Error loading references.</p>';
            });
    }
    
    function copyPromptContent() {
        // Determine which content to copy based on current view
        const content = document.getElementById('expanded-content').classList.contains('active') 
            ? expandedContent 
            : editor.getValue();
            
        // Copy to clipboard
        navigator.clipboard.writeText(content)
            .then(() => {
                showToast('Copied to clipboard');
            })
            .catch(error => {
                console.error('Error copying to clipboard:', error);
                showToast('Error copying to clipboard', 'danger');
                
                // Fallback method for browsers that don't support clipboard API
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = content;
                    textarea.style.position = 'fixed';  // Avoid scrolling to bottom
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showToast('Copied to clipboard (fallback method)');
                } catch (fallbackError) {
                    console.error('Fallback copy failed:', fallbackError);
                    showToast('Could not copy to clipboard', 'danger');
                }
            });
    }
    
    function toggleView() {
        // Toggle between raw and expanded view
        const rawTab = document.getElementById('raw-tab');
        const expandedTab = document.getElementById('expanded-tab');
        
        if (rawTab.classList.contains('active')) {
            rawTab.classList.remove('active');
            document.getElementById('raw-content').classList.remove('show', 'active');
            
            expandedTab.classList.add('active');
            document.getElementById('expanded-content').classList.add('show', 'active');
            
            // Update expanded view
            updateExpandedView();
        } else {
            expandedTab.classList.remove('active');
            document.getElementById('expanded-content').classList.remove('show', 'active');
            
            rawTab.classList.add('active');
            document.getElementById('raw-content').classList.add('show', 'active');
        }
    }
    
    function showDeleteConfirmation() {
        const deleteModal = new bootstrap.Modal(document.getElementById('deletePromptModal'));
        deleteModal.show();
    }
    
    function deletePrompt() {
        // Send DELETE request
        fetch(`/api/prompts/${promptId}`, {
            method: 'DELETE'
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to delete prompt');
            }
            return response.json();
        })
        .then(data => {
            // Success - redirect to prompts list
            showToast('Prompt deleted successfully');
            
            // Redirect after a short delay
            setTimeout(() => {
                window.location.href = '/manage/prompts';
            }, 1000);
        })
        .catch(error => {
            console.error('Error deleting prompt:', error);
            showToast('Error deleting prompt: ' + error.message, 'danger');
        });
    }
    
    function showWarnings(warnings) {
        const warningsCard = document.getElementById('warnings-card');
        const warningsContainer = document.getElementById('warnings');
        
        // Create warning message HTML
        let html = '<ul class="list-group">';
        
        warnings.forEach(warning => {
            html += `
                <li class="list-group-item list-group-item-warning">
                    <i class="bi bi-exclamation-triangle-fill me-2"></i>
                    ${warning}
                </li>
            `;
        });
        
        html += '</ul>';
        
        // Update warnings container and show card
        warningsContainer.innerHTML = html;
        warningsCard.style.display = 'block';
    }
    
    function hideWarnings() {
        const warningsCard = document.getElementById('warnings-card');
        warningsCard.style.display = 'none';
    }
    
    // Load all prompts for autocomplete
    function loadAllPrompts() {
        fetch('/api/prompts/all')
            .then(response => response.json())
            .then(prompts => {
                // Store the prompts for autocomplete
                allPrompts = prompts.map(p => p.id);
                console.log(`Loaded ${allPrompts.length} prompts for autocomplete`);
            })
            .catch(error => {
                console.error('Error loading prompts for autocomplete:', error);
            });
    }
    
    // Set up the prompt completion functionality
    function setupPromptCompletion() {
        // Define our custom hint function
        window.promptHint = function(editor, options) {
            const cursor = editor.getCursor();
            const line = editor.getLine(cursor.line);
            const lineBeforeCursor = line.substring(0, cursor.ch);
            
            // Check if we're typing after [[ 
            const match = lineBeforeCursor.match(/\[\[([^\]]*?)$/);
            if (!match) return null;
            
            const prefix = match[1]; // The text after [[ but before cursor
            
            // Filter prompts based on prefix
            const filteredPrompts = allPrompts.filter(prompt => 
                prompt.toLowerCase().includes(prefix.toLowerCase())
            );
            
            if (filteredPrompts.length === 0) return null;
            
            return {
                list: filteredPrompts.map(prompt => ({ 
                    text: prompt + "]]", 
                    displayText: prompt 
                })),
                from: { line: cursor.line, ch: cursor.ch - prefix.length },
                to: cursor
            };
        };
        
        // Listen for [[ key sequence to trigger autocomplete
        editor.on('keyup', function(cm, event) {
            const cursor = cm.getCursor();
            const line = cm.getLine(cursor.line);
            const lineBeforeCursor = line.substring(0, cursor.ch);
            
            // Check if we just typed [[ or are within a [[ ]] pair
            if (lineBeforeCursor.endsWith('[[') || lineBeforeCursor.match(/\[\[([^\]]*?)$/)) {
                cm.showHint({ hint: promptHint, completeSingle: false });
            }
        });
    }
</script>
{% endblock %}

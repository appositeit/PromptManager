{% extends "base.html" %}
{% from "macros/prompt_modal.html" import new_prompt_modal %}

{% block title %}Manage Prompts{% endblock %}

{% block header_title %}Manage Prompts & Directories{% endblock %}

{% block header_actions %}
    <div class="btn-group me-2">
        <button class="btn btn-primary" id="add-prompt-btn" title="Create a new prompt (Alt+N)" data-bs-toggle="modal" data-bs-target="#newPromptModal">
            <i class="bi bi-plus-circle-fill"></i> New Prompt
    </button>
        <button class="btn btn-secondary" id="add-directory-modal-btn" title="Add a new prompt directory" data-bs-toggle="modal" data-bs-target="#addDirectoryModal">
            <i class="bi bi-folder-plus"></i> Add Directory
        </button>
        <button class="btn btn-info" id="refresh-all-btn" title="Reload prompts from all directories">
        <i class="bi bi-arrow-clockwise"></i> Refresh All
    </button>
</div>
    {{ super() }} {# This will include the help button from base.html #}
{% endblock %}

{% block modal_help_content %}
    <h4>Manage Prompts & Directories Help</h4>
    <p>This page allows you to view, create, and manage your prompts and prompt directories.</p>
    
    <h5>Keyboard Shortcuts</h5>
    <table class="table table-sm table-bordered">
        <thead>
            <tr><th>Shortcut</th><th>Action</th></tr>
        </thead>
        <tbody>
            <tr><td><code>Alt + N</code></td><td>Create a new prompt</td></tr>
            <tr><td><code>Alt + H</code> or click <i class="bi bi-question-circle"></i></td><td>Show this help dialog</td></tr>
        </tbody>
    </table>

    <h5>Functionality</h5>
    <h6>Prompts Table:</h6>
    <ul>
        <li>Displays all available prompts.</li>
        <li><strong>Name:</strong> Click to open the prompt editor.</li>
        <li><strong>Description:</strong> A brief description of the prompt.</li>
        <li><strong>Tags:</strong> Keywords associated with the prompt.</li>
        <li><strong>Type:</strong> Indicates if a prompt is 'Standard' or 'Composite' (contains inclusions).</li>
        <li><strong>Modified:</strong> Last modification date. Click to sort.</li>
        <li><strong>Actions:</strong>
            <ul>
                <li><i class="bi bi-pencil-fill"></i> Edit: Open the prompt in the editor.</li>
                <li><i class="bi bi-trash-fill"></i> Delete: Delete the prompt (with confirmation).</li>
            </ul>
        </li>
        <li>Use the search box to filter prompts by name, description, or tags.</li>
    </ul>

    <h6>Directories Table:</h6>
    <ul>
        <li>Displays all registered prompt directories.</li>
        <li><strong>Name:</strong> Display name for the directory.</li>
        <li><strong>Path:</strong> Filesystem path to the directory.</li>
        <li><strong>Description:</strong> A brief description of the directory.</li>
        <li><strong>Actions:</strong>
            <ul>
                <li><i class="bi bi-arrow-clockwise"></i> Refresh: Reload prompts from this specific directory.</li>
                <li><i class="bi bi-trash-fill"></i> Remove: Remove the directory from Prompt Manager (does not delete files).</li>
            </ul>
        </li>
    </ul>

    <h6>Buttons:</h6>
    <ul>
        <li><strong>New Prompt:</strong> Opens the editor to create a new prompt.</li>
        <li><strong>Add Directory:</strong> Opens a dialog to register a new directory containing prompts.</li>
        <li><strong>Refresh All:</strong> Reloads prompts from all registered directories.</li>
    </ul>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <div class="row align-items-center">
                        <div class="col">
                            <h5 class="card-title mb-0">Prompts <span id="prompts-count" class="text-muted small"></span></h5>
                        </div>
                        <div class="col-auto">
                            <div class="input-group">
                                <input type="text" class="form-control" id="prompt-search" placeholder="Search prompts...">
                                <button class="btn btn-outline-secondary" type="button" id="prompt-search-btn">
                                    <i class="bi bi-search"></i>
                                </button>
                                <button class="btn btn-outline-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                    <i class="bi bi-funnel"></i>
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end">
                                    <li><h6 class="dropdown-header">Filter by Tag</h6></li>
                                    <li><a class="dropdown-item" href="#" data-tag="all">All Tags</a></li>
                                    <div id="tag-filters">
                                        <!-- Tags will be populated dynamically -->
                                    </div>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-hover">
                            <thead>
                                <tr class="sortable-headers">
                                    <th data-sort="directory" class="sortable">Directory <i class="bi bi-sort-alpha-down sort-icon"></i></th>
                                    <th data-sort="id" class="sortable">Name <i class="bi bi-sort-alpha-down sort-icon"></i></th>
                                    <th data-sort="description" class="sortable">Description <i class="bi bi-sort-alpha-down sort-icon"></i></th>
                                    <th data-sort="tags" class="sortable">Tags <i class="bi bi-sort-alpha-down sort-icon"></i></th>
                                    <th data-sort="updated" class="sortable">Last Updated <i class="bi bi-sort-alpha-down sort-icon"></i></th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="prompts-table-body">
                                <!-- Prompts will be loaded dynamically -->
                                <tr>
                                    <td colspan="6" class="text-center py-4">
                                        <div class="spinner-border text-primary" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                        <p class="mb-0 mt-2">Loading prompts...</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Directories <span id="directories-count" class="text-muted small"></span></h5>
                    <button class="btn btn-outline-primary" data-bs-toggle="modal" data-bs-target="#addDirectoryModal" title="Add New Directory (Alt+A)">
                        <i class="bi bi-folder-plus"></i> Add Directory
                    </button>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-hover" id="directories-table">
                            <thead>
                                <tr class="sortable-headers">
                                    <th data-sort="name" class="sortable">Name <i class="bi bi-sort-alpha-down sort-icon"></i></th>
                                    <th data-sort="status" class="sortable">Status <i class="bi bi-sort-alpha-down sort-icon"></i></th>
                                    <th data-sort="path" class="sortable">Path <i class="bi bi-sort-alpha-down sort-icon"></i></th>
                                    <th data-sort="description" class="sortable">Description <i class="bi bi-sort-alpha-down sort-icon"></i></th>
                                    <th class="actions-column">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="directories-table-body">
                                <!-- Directories will be loaded dynamically -->
                                <tr>
                                    <td colspan="5" class="text-center py-4">
                                        <div class="spinner-border text-primary" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                        <p class="mb-0 mt-2">Loading directories...</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{{ new_prompt_modal('manage_prompts') }}

<!-- Add Directory Modal -->
<div class="modal fade" id="addDirectoryModal" tabindex="-1" aria-labelledby="addDirectoryModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addDirectoryModalLabel">Add Prompt Directory</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="addDirectoryForm">
                    <div class="mb-3 suggestions-container">
                        <label for="directoryPath" class="form-label" title="Tab for path completion, Alt+T to move to next field.">Directory Path</label>
                        <input type="text" class="form-control" id="directoryPath" required autocomplete="off" title="Tab for path completion, Alt+T to move to next field.">
                        <!-- Suggestions list will be inserted here by JavaScript -->
                    </div>
                    <div class="mb-3">
                        <label for="directoryName" class="form-label" title="Alt+T to navigate fields. Ctrl+Enter to Add, Ctrl+Esc to Cancel.">Display Name</label>
                        <input type="text" class="form-control" id="directoryName" title="Alt+T to navigate fields. Ctrl+Enter to Add, Ctrl+Esc to Cancel.">
                        <div class="form-text">If not provided, the directory name will be used</div>
                    </div>
                    <div class="mb-3">
                        <label for="directoryDescription" class="form-label" title="Alt+T to navigate fields. Ctrl+Enter to Add, Ctrl+Esc to Cancel.">Description</label>
                        <input type="text" class="form-control" id="directoryDescription" title="Alt+T to navigate fields. Ctrl+Enter to Add, Ctrl+Esc to Cancel.">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" title="Cancel (Ctrl+Esc)">Cancel</button>
                <button type="button" class="btn btn-primary" id="addDirectoryBtn" title="Add (Ctrl+Enter)">Add</button>
            </div>
        </div>
    </div>
</div>

<!-- Edit Directory Modal -->
<div class="modal fade" id="editDirectoryModal" tabindex="-1" aria-labelledby="editDirectoryModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editDirectoryModalLabel">Edit Directory</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="editDirectoryForm">
                    <input type="hidden" id="editDirectoryPath">
                    <div class="mb-3">
                        <label class="form-label">Directory Path</label>
                        <p class="form-control-plaintext ps-2" id="displayDirectoryPath"></p>
                    </div>
                    <div class="mb-3">
                        <label for="editDirectoryName" class="form-label">Display Name</label>
                        <input type="text" class="form-control" id="editDirectoryName" required>
                    </div>
                    <div class="mb-3">
                        <label for="editDirectoryDescription" class="form-label">Description</label>
                        <input type="text" class="form-control" id="editDirectoryDescription">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="updateDirectoryBtn">Update</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Prompt Confirmation Modal -->
<div class="modal fade" id="deletePromptModal" tabindex="-1" aria-labelledby="deletePromptModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deletePromptModalLabel">Confirm Deletion</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete the prompt <strong id="delete-prompt-id"></strong>?</p>
                <p class="text-danger">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirm-delete-btn">Delete</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Directory Confirmation Modal -->
<div class="modal fade" id="deleteDirectoryModal" tabindex="-1" aria-labelledby="deleteDirectoryModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deleteDirectoryModalLabel">Confirm Deletion</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to remove this directory?</p>
                <p class="text-danger">This will remove the directory from the system, but will not delete any files.</p>
                <p><strong id="delete-directory-path"></strong></p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirm-delete-directory-btn">Remove</button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block page_specific_js %}
{# <script src="/static/js/utils.js"></script> #} {# Redundant: Already loaded in base.html #}
<script src="/static/js/new_prompt_modal.js"></script>
<script src="/static/js/directory_manager.js"></script>
<style>
    /* Styles for sortable headers */
    .sortable {
        cursor: pointer;
        position: relative;
        padding-right: 20px; /* Space for the sort icon */
    }
    
    .sortable:hover {
        background-color: rgba(0, 0, 0, 0.03);
    }
    
    .sort-icon {
        font-size: 0.8rem;
        position: absolute;
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
        opacity: 0.3;
    }
    
    .sort-active .sort-icon {
        opacity: 1;
    }
    
    .sort-asc .sort-icon {
        transform: translateY(-50%) rotate(0deg);
    }
    
    .sort-desc .sort-icon {
        transform: translateY(-50%) rotate(180deg);
    }
    
    /* Directory column styling */
    table th:nth-child(1), /* Directory */
    table td:nth-child(1) {
        /*max-width: 150px;*/
        /*width: 15%;*/
        word-break: break-word;
    }
    /* Make description and tags columns smaller */
    table th:nth-child(3), /* Description */
    table td:nth-child(3) {
        /*max-width: 200px;*/
        /*width: 15%;*/
    }
    table th:nth-child(5), /* Tags */
    table td:nth-child(5) {
        /*max-width: 150px;*/
        /*width: 15%;*/
    }
    table th:nth-child(6), /* Last Updated */
    table td:nth-child(6) {
        /*width: 10%;*/
    }
    
    /* Selected row styling */
    tr.selected {
        background-color: rgba(13, 110, 253, 0.15);
        outline: 2px solid rgba(13, 110, 253, 0.5);
    }
    
    /* Add focus styling for the search box */
    #prompt-search:focus {
        border-color: #86b7fe;
        box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
    }
    
    /* Status toggle cursor and styling */
    .status-badge {
        cursor: pointer;
        padding: 6px 10px;
        border-radius: 4px;
        transition: all 0.2s ease;
    }
    
    .status-badge:hover {
        filter: brightness(90%);
        box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
    }
    
    .status-badge:active {
        transform: scale(0.95);
    }

    /* Styles for path completion suggestions */
    .suggestions-container {
        position: relative; /* Needed for absolute positioning of the list */
    }
    .suggestions-list {
        position: absolute;
        background-color: #fff;
        border: 1px solid #eee;
        border-top: none;
        z-index: 1050; /* Ensure it's above other elements, like modal backdrop */
        list-style-type: none;
        padding: 0;
        margin: 0;
        max-height: 150px;
        overflow-y: auto;
        width: 100%; /* Match the width of the input typically */
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .suggestions-list li {
        padding: 8px 12px;
        cursor: pointer;
    }
    .suggestions-list li:hover {
        background-color: #f0f0f0;
    }
    .suggestions-list li.selected-suggestion {
        background-color: #e0e0e0;
    }

    /* Styles for the Actions columns */
    table th:nth-child(6), /* Prompts table Actions */
    table td:nth-child(6) {
        width: 120px;
        min-width: 100px;
        max-width: 160px;
    }
    
    /* Styles for Directories table Actions column */
    #directories-table .actions-column,
    #directories-table td:nth-child(5) {
        width: 120px !important;
        min-width: 120px !important;
        max-width: 160px !important;
        white-space: nowrap;
    }
</style>
<script>
    // Global variables
    let prompts = [];
    let allPrompts = [];
    let directories = [];
    let currentFilter = {
        type: 'all',
        tag: 'all',
        search: ''
    };
    
    // Sort settings
    let currentSort = {
        column: 'directory',
        direction: 'asc'
    };
    
    // Directory sort settings
    let currentDirectorySort = {
        column: 'name',
        direction: 'asc'
    };

    // Debounce utility function
    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    }
    
    /**
     * Perform a stable sort on an array based on a given comparison function.
     * This ensures that equal elements maintain their relative order.
     * 
     * @param {Array} array - The array to sort
     * @param {Function} compareFunction - Function that defines the sort order
     * @returns {Array} The sorted array
     */
    function stableSort(array, compareFunction) {
        // Add indices to track original order
        const indexed = array.map((item, index) => [item, index]);
        
        // Sort with original index as tiebreaker
        indexed.sort((a, b) => {
            const compareResult = compareFunction(a[0], b[0]);
            return compareResult === 0 ? a[1] - b[1] : compareResult;
        });
        
        // Extract the sorted items
        return indexed.map(pair => pair[0]);
    }
    
    // Default prompts content
    const defaultPrompts = {
        architect: {
            id: 'architect_role',
            content: `# Architect Role

You are the Architect AI in the Coordinator multi-agent system. Your role is to analyze problems, design solutions, and coordinate the work of specialized Worker AIs. As the Architect, you:

1. **Analyze the user's requirements** and break down complex tasks into manageable subtasks
2. **Assign tasks to appropriate Worker AIs** based on their specialized capabilities
3. **Integrate results** from Workers into comprehensive solutions
4. **Maintain context** across the entire project
5. **Communicate clearly** with both users and Worker AIs

You have access to various tools and Workers with specialized capabilities. When delegating tasks, be specific about:
- The exact task to be performed
- The expected output format
- Any relevant context or constraints

Always thank Workers for their contributions and acknowledge their work when presenting solutions to users. If a Worker fails to complete a task or provides incomplete results, work with them to refine the request or assign the task to a different Worker.

Remember that you're the coordinator of the system - make decisions, provide guidance, and ensure that the final solution meets the user's needs.`,
            description: 'System prompt for the Architect AI',
            tags: ['architect', 'system', 'role']
        },
        worker: {
            id: 'worker_role',
            content: `# Worker Role

You are a specialized Worker AI in the Coordinator multi-agent system. Your role is to perform specific tasks assigned by the Architect AI. As a Worker, you:

1. **Focus on your area of expertise** to complete assigned tasks
2. **Follow the Architect's instructions** precisely
3. **Ask clarifying questions** if a task is unclear
4. **Provide results** in the requested format
5. **Explain your approach** when helpful

When communicating with the Architect:
- Acknowledge receipt of tasks
- Indicate when you're working on a task
- Report any difficulties or limitations
- Provide complete results when finished

You don't need to maintain the full context of the project - that's the Architect's responsibility. Instead, focus on executing your assigned tasks to the best of your abilities and providing high-quality results that the Architect can integrate into the final solution.

Remember that you're part of a team - your specialized work contributes to solving the user's larger problem.`,
            description: 'System prompt for Worker AIs',
            tags: ['worker', 'system', 'role']
        }
    };
    
    // Function to refresh a specific directory - using the imported function from directory_manager.js
    function refreshDirectory(directoryPath) {
        // Show loading toast
        showToast('Refreshing directory...', 'info');
        
        // Use the imported function
        reloadDirectory(directoryPath)
            .then(data => {
                // Reload prompts to reflect changes
                loadPrompts();
                showToast(`Successfully reloaded ${data.count} prompts from directory`, 'success');
            })
            .catch(error => {
                console.error('Error refreshing directory:', error);
                showToast(`Error refreshing directory: ${error.message}`, 'danger');
                
                // Try refreshing all as a fallback
                loadPrompts();
            });
    }
    
    // Function to refresh all directories - using the imported function from directory_manager.js
    function refreshAllDirectories() {
        // Show loading toast
        showToast('Refreshing all directories...', 'info');
        
        // Use the imported function
        reloadAllPrompts()
            .then(data => {
                // Reload prompts to reflect changes with stronger error handling
                loadPrompts()
                    .then(() => {
                        showToast(`Successfully reloaded ${data.count} prompts from all directories`, 'success');
                    })
                    .catch(promptError => {
                        console.error('Error reloading prompts after directory refresh:', promptError);
                        showToast(`Successfully refreshed directories but had trouble displaying prompts: ${promptError.message}`, 'warning');
                    });
            })
            .catch(error => {
                console.error('Error refreshing directories:', error);
                showToast(`Error refreshing directories: ${error.message}`, 'danger');
                
                // Try regular reload as a fallback with stronger error handling
                loadPrompts()
                    .then(() => {
                        showToast('Successfully refreshed prompt list', 'success');
                    })
                    .catch(promptError => {
                        console.error('Error with fallback prompt reload:', promptError);
                        showToast(`Failed to load prompts: ${promptError.message}`, 'danger');
                    });
            });
    }

    // Force a direct API request immediately on page load
    window.addEventListener('load', function() {
        console.log('Window loaded - ensuring directories and then fetching prompts');
        
        loadDirectories().then(() => {
            console.log('Directories loaded on window.load, now fetching prompts');
        fetch('/api/prompts/all')
            .then(response => response.json())
            .then(data => {
                console.log('Directly fetched prompts on window load:', data.length);
                allPrompts = data;
                updatePromptsTable();
                updateTagFilters();
            })
            .catch(err => console.error('Direct prompt fetch error:', err));
        }).catch(dirErr => {
            console.error('Failed to load directories on window.load:', dirErr);
            // Still try to load prompts as a fallback
            fetch('/api/prompts/all')
                .then(response => response.json())
                .then(data => {
                    console.log('Directly fetched prompts on window load (after dir load failure):', data.length);
                    allPrompts = data;
                    updatePromptsTable();
                    updateTagFilters();
                })
                .catch(err => console.error('Direct prompt fetch error (after dir load failure):', err));
        });
    });
    
    document.addEventListener('DOMContentLoaded', function() {
        // console.log('[DEBUG] DOMContentLoaded: Event listener fired.'); // Removed
        
        // Add Alt+N shortcut for "New Prompt"
        document.addEventListener('keydown', function(e) {
            if (e.altKey && e.key.toLowerCase() === 'n') {
                // Ensure not in an input field where Alt+N might be legitimate
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'SELECT') {
                    return;
                }
                e.preventDefault();
                const newPromptModal = new bootstrap.Modal(document.getElementById('newPromptModal'));
                newPromptModal.show();
                setTimeout(() => {
                    document.getElementById('promptName').focus();
                }, 300); // Delay focus slightly for modal to open
            }
        });
        
        // Add Alt+A shortcut for "Add Directory" modal
        document.addEventListener('keydown', function(e) {
            if (e.altKey && e.key.toLowerCase() === 'a') {
                // Ensure not in an input field where Alt+A might be legitimate (e.g., select all)
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'SELECT') {
                    return;
                }
                e.preventDefault();
                const addDirectoryModal = new bootstrap.Modal(document.getElementById('addDirectoryModal'));
                addDirectoryModal.show();
                // Focus the directoryPathInput field after modal opens
                setTimeout(() => {
                    const dirPathInput = document.getElementById('directoryPath');
                    if (dirPathInput) dirPathInput.focus();
                }, 300); // Delay focus slightly for modal to open
            }
        });
        
        // Initialize by loading prompts and directories
        // console.log('[DEBUG] DOMContentLoaded: About to call Promise.all for loadPrompts and loadDirectories.'); // Removed
        Promise.all([
            loadPrompts(),
            loadDirectories()
        ]).then(() => {
            console.log('Successfully loaded prompts and directories on page initialization');
        }).catch(error => {
            console.error('Error during page initialization:', error);
            showToast('Error loading data. Trying alternative loading method...', 'warning');
            
            // Force a reload if the initial load fails
            setTimeout(() => {
                refreshAllDirectories();
            }, 500);
        });
        
        // Set up refresh all button
        document.getElementById('refresh-all-btn').addEventListener('click', refreshAllDirectories);
        
        // Set up event handlers - search immediately on typing
        document.getElementById('prompt-search').addEventListener('input', function() {
            currentFilter.search = this.value;
            filterPrompts();
        });
        
        // Keep the button functionality for compatibility
        document.getElementById('prompt-search-btn').addEventListener('click', function() {
            currentFilter.search = document.getElementById('prompt-search').value;
            filterPrompts();
        });
        
        // Add focus to search box when page loads and when no item is selected
        document.addEventListener('keydown', function(event) {
            // If a text input or textarea isn't focused and user starts typing a letter/number
            if (document.activeElement.tagName !== 'INPUT' && 
                document.activeElement.tagName !== 'TEXTAREA' &&
                document.activeElement.tagName !== 'SELECT' &&
                event.key.length === 1 && !event.ctrlKey && !event.altKey && !event.metaKey) {
                // Focus the search box and add the typed character
                const searchBox = document.getElementById('prompt-search');
                searchBox.focus();
                // Don't overwrite the value as the input event will handle the filtering
            }
        });
        
        // Set up sorting functionality
        const sortableHeaders = document.querySelectorAll('.sortable');
        sortableHeaders.forEach(header => {
            header.addEventListener('click', function() {
                const column = this.dataset.sort;
                const table = this.closest('table');
                const isDirectoriesTable = table.id === 'directories-table';
                
                if (isDirectoriesTable) {
                    // Handle directory table sorting
                    if (currentDirectorySort.column === column) {
                        currentDirectorySort.direction = currentDirectorySort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentDirectorySort.column = column;
                        currentDirectorySort.direction = 'asc';
                    }
                    
                    // Update visuals and re-sort
                    updateDirectorySortHeaders();
                    updateDirectoriesUI();
                } else {
                    // Handle prompts table sorting
                    if (currentSort.column === column) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.column = column;
                        currentSort.direction = 'asc';
                    }
                    
                    // Update visuals and re-sort
                    updateSortHeaders();
                    updatePromptsTable();
                }
            });
        });
        
        // Initialize sort headers
        updateSortHeaders();
        updateDirectorySortHeaders();
        
        // Add keyboard navigation for the prompt table - enhanced to work with search box focus
        document.addEventListener('keydown', function(event) {
            const promptsTable = document.getElementById('prompts-table-body');
            if (!promptsTable) return;
            
            const rows = promptsTable.querySelectorAll('tr');
            if (!rows.length) return;
            
            // Find the currently selected row
            let selectedRow = promptsTable.querySelector('tr.selected');
            let selectedIndex = -1;
            
            if (selectedRow) {
                // Find the index of the selected row
                for (let i = 0; i < rows.length; i++) {
                    if (rows[i] === selectedRow) {
                        selectedIndex = i;
                        break;
                    }
                }
            }
            
            // Special handling for search box
            const isSearchBoxFocused = document.activeElement === document.getElementById('prompt-search');
            
            // Handle up/down arrow keys for navigation regardless of focus
            if (event.key === 'ArrowDown' && (isSearchBoxFocused || 
                !(event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT'))) {
                event.preventDefault();
                
                if (selectedIndex === -1 || selectedIndex >= rows.length - 1) {
                    // Select the first row if nothing is selected or at the end
                    selectedIndex = 0;
                } else {
                    // Select the next row
                    selectedIndex++;
                }
                
                // Update selection
                updateRowSelection(rows, selectedIndex);
            } else if (event.key === 'ArrowUp' && (isSearchBoxFocused || 
                !(event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT'))) {
                event.preventDefault();
                
                if (selectedIndex <= 0) {
                    // Select the last row if nothing is selected or at the beginning
                    selectedIndex = rows.length - 1;
                } else {
                    // Select the previous row
                    selectedIndex--;
                }
                
                // Update selection
                updateRowSelection(rows, selectedIndex);
            } else if (event.key === 'Enter' && selectedRow && 
                (isSearchBoxFocused || 
                !(event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT'))) {
                event.preventDefault();
                
                // Navigate to the selected prompt
                const promptLink = selectedRow.querySelector('a');
                if (promptLink) {
                    window.location.href = promptLink.href;
                }
            }
        });
        
        // Initialize new prompt modal
        newPromptModal = new NewPromptModal('manage_prompts');
        

        
        // Add directory form handler
        const addDirectoryForm = document.getElementById('addDirectoryForm');
        const addDirectoryBtn = document.getElementById('addDirectoryBtn');
        const directoryPathInput = document.getElementById('directoryPath');
        const directoryNameInput = document.getElementById('directoryName');
        const directoryDescriptionInput = document.getElementById('directoryDescription');
        const addDirectoryModalElement = document.getElementById('addDirectoryModal');

        let suggestionsListElement = null; 
        let activeSuggestionIndex = -1;

        function displayPathSuggestions(suggestions, inputElement, baseCompletedPathForSelection) {
            const container = inputElement.parentElement; // Should be .suggestions-container
            if (!suggestionsListElement) {
                suggestionsListElement = document.createElement('ul');
                suggestionsListElement.className = 'suggestions-list';
                suggestionsListElement.id = 'directory-path-suggestions';
                container.appendChild(suggestionsListElement);
            }

            suggestionsListElement.innerHTML = ''; // Clear old suggestions
            activeSuggestionIndex = -1; // Reset active suggestion

            if (suggestions && suggestions.length > 0) {
                suggestions.forEach((suggestionText, index) => {
                    const li = document.createElement('li');
                    li.textContent = suggestionText;
                    li.addEventListener('mousedown', function(e) { // Use mousedown to fire before blur
                        e.preventDefault(); // Prevent input blur
                        
                        let finalPath;
                        // baseCompletedPathForSelection is data.completed_path from the API for the suggestion list context
                        if (baseCompletedPathForSelection.endsWith('/')) {
                            finalPath = baseCompletedPathForSelection + suggestionText;
                        } else {
                            const lastSlashIndex = baseCompletedPathForSelection.lastIndexOf('/');
                            const dirPart = (lastSlashIndex === -1) ? '' : baseCompletedPathForSelection.substring(0, lastSlashIndex + 1);
                            finalPath = dirPart + suggestionText;
                        }
                        finalPath = finalPath.replace(/\/\/+/g, '/');
                        inputElement.value = finalPath;
                        suggestionsListElement.style.display = 'none';
                        inputElement.focus();
                    });
                    suggestionsListElement.appendChild(li);
                });
                suggestionsListElement.style.display = 'block';
            } else {
                suggestionsListElement.style.display = 'none';
            }
        }

        if (addDirectoryBtn && addDirectoryForm && directoryPathInput) {
            const debouncedFetchSuggestions = debounce(async function(inputValue) {
                if (!suggestionsListElement || suggestionsListElement.style.display !== 'block') {
                    // Don't fetch if suggestions are not meant to be visible
                    // or if list element doesn't exist yet (should be created by Tab first)
                    return;
                }
                if (!inputValue && suggestionsListElement) {
                    suggestionsListElement.innerHTML = '';
                    suggestionsListElement.style.display = 'none';
                    activeSuggestionIndex = -1;
                    return;
                }
                if (!inputValue) return;

                try {
                    const response = await fetch('/api/prompts/filesystem/complete_path', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ partial_path: inputValue })
                    });
                    if (!response.ok) {
                        // Don't show error toast on every keystroke, just clear suggestions
                        if (suggestionsListElement) suggestionsListElement.style.display = 'none';
                        return;
                    }
                    const data = await response.json();
                    // When dynamically filtering, we use the current input value as the base for selection,
                    // as data.completed_path might be different from what user is currently typing.
                    // OR, we can pass data.completed_path to ensure consistency if API handles it well.
                    // For now, let's assume suggestions are always relative to data.completed_path.
                    displayPathSuggestions(data.suggestions, directoryPathInput, data.completed_path);
                } catch (error) {
                    console.error('Dynamic suggestion fetch error:', error);
                    if (suggestionsListElement) suggestionsListElement.style.display = 'none';
                }
            }, 300); // 300ms debounce delay

            directoryPathInput.addEventListener('input', function(event) {
                const currentVal = this.value;
                if (suggestionsListElement && suggestionsListElement.style.display === 'block') {
                    debouncedFetchSuggestions(currentVal);
                } else if (currentVal === '' && suggestionsListElement) {
                    // If user clears input and list was visible, hide it.
                    suggestionsListElement.innerHTML = '';
                    suggestionsListElement.style.display = 'none';
                    activeSuggestionIndex = -1;
                }
            });

            directoryPathInput.addEventListener('keydown', async function(event) {
                // Alt+T: Move to next field (Display Name)
                if (event.altKey && event.key.toLowerCase() === 't') {
                    console.log('Alt+T detected in directoryPathInput');
                    event.preventDefault();
                    directoryNameInput.focus();
                    return;
                }

                // Plain Tab: Path completion
                if (event.key === 'Tab' && !event.altKey && !event.shiftKey && !event.ctrlKey) { 
                    event.preventDefault();
                    const partialPath = this.value;
                    if (!partialPath && suggestionsListElement) {
                        suggestionsListElement.style.display = 'none';
                        return;
                    }
                    if (!partialPath) return;
                    // ... (rest of plain Tab logic for API call and displayPathSuggestions) ...
                    try {
                        const response = await fetch('/api/prompts/filesystem/complete_path', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ partial_path: partialPath })
                        });
                        if (!response.ok) {
                            const errorData = await response.json();
                            showToast(`Path completion failed: ${errorData.detail || response.statusText}`, 'danger');
                            if (suggestionsListElement) suggestionsListElement.style.display = 'none';
                            return;
                        }
                        const data = await response.json();
                        this.value = data.completed_path; 
                        displayPathSuggestions(data.suggestions, this, data.completed_path);
                    } catch (error) {
                        showToast('Error fetching path completions.', 'danger');
                        if (suggestionsListElement) suggestionsListElement.style.display = 'none';
                    }
                    return; // Stop after handling Tab
                }

                // Suggestion list navigation (only if list is visible)
                if (suggestionsListElement && suggestionsListElement.style.display === 'block') {
                    if (event.key === 'ArrowDown') {
                        event.preventDefault();
                        if (activeSuggestionIndex < suggestionsListElement.children.length - 1) {
                            activeSuggestionIndex++;
                            updateSuggestionHighlight();
                        }
                        return;
                    }
                    if (event.key === 'ArrowUp') {
                        event.preventDefault();
                        if (activeSuggestionIndex > 0) {
                            activeSuggestionIndex--;
                            updateSuggestionHighlight();
                        }
                        return;
                    }
                    if (event.key === 'Enter' && activeSuggestionIndex > -1) {
                        event.preventDefault();
                        suggestionsListElement.children[activeSuggestionIndex].dispatchEvent(new Event('mousedown'));
                        return;
                    }
                }

                // Escape: Close suggestion list if open
                if (event.key === 'Escape') {
                    if (suggestionsListElement && suggestionsListElement.style.display === 'block') {
                        event.preventDefault();
                        suggestionsListElement.style.display = 'none';
                        activeSuggestionIndex = -1; // Reset index
                        // Do not return here, allow Escape to bubble if suggestions were not open for modal closure
                    }
                }
            });

            directoryNameInput.addEventListener('keydown', function(event) {
                // Alt+T: Navigate fields
                if (event.altKey && event.key.toLowerCase() === 't') {
                    event.preventDefault();
                    if (event.shiftKey) { // Alt+Shift+T to go to previous (Path)
                        directoryPathInput.focus();
                    } else { // Alt+T to go to next (Description)
                        directoryDescriptionInput.focus();
                    }
                }
            });

            directoryDescriptionInput.addEventListener('keydown', function(event) {
                // Alt+T: Navigate fields
                if (event.altKey && event.key.toLowerCase() === 't') {
                    event.preventDefault();
                    if (event.shiftKey) { // Alt+Shift+T to go to previous (Name)
                        directoryNameInput.focus();
                    } else { // Alt+T to go to first (Path)
                        directoryPathInput.focus(); 
                    }
                }
            });

            // Modal-wide shortcuts for Ctrl+Enter and Ctrl+Esc
            if (addDirectoryModalElement) {
                addDirectoryModalElement.addEventListener('keydown', function(event) {
                    if (event.ctrlKey && event.key === 'Enter') {
                        event.preventDefault();
                        addDirectoryBtn.click(); // Simulate click on Add button
                    } else if (event.ctrlKey && event.key === 'Escape') {
                        event.preventDefault();
                        // Find the cancel button and click it
                        const cancelBtn = addDirectoryModalElement.querySelector('.modal-footer button[data-bs-dismiss="modal"]');
                        if (cancelBtn) {
                            cancelBtn.click();
                        }
                    }
                });
            }

            directoryPathInput.addEventListener('blur', function() {
                // Delay hiding to allow click on suggestion to register
                setTimeout(() => {
                    if (suggestionsListElement && suggestionsListElement.style.display === 'block' && !suggestionsListElement.matches(':hover')) {
                         suggestionsListElement.style.display = 'none';
                    }
                }, 150);
            });
            
            function updateSuggestionHighlight() {
                for (let i = 0; i < suggestionsListElement.children.length; i++) {
                    suggestionsListElement.children[i].classList.remove('selected-suggestion');
                }
                if (activeSuggestionIndex > -1) {
                    suggestionsListElement.children[activeSuggestionIndex].classList.add('selected-suggestion');
                    suggestionsListElement.children[activeSuggestionIndex].scrollIntoView({ block: 'nearest' });
                }
            }

            addDirectoryBtn.addEventListener('click', addDirectory);
        }
        
        // Edit directory form handler
        const updateDirectoryBtn = document.getElementById('updateDirectoryBtn');
        if (updateDirectoryBtn) {
            updateDirectoryBtn.addEventListener('click', handleUpdateDirectoryForm);
        }
        
        // Delete prompt confirmation
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
        if (confirmDeleteBtn) {
            confirmDeleteBtn.addEventListener('click', function() {
                const promptIdElement = document.getElementById('delete-prompt-id');
                // Use the stored ID attribute (which may be the unique ID) for deletion
                const promptId = promptIdElement.dataset.id || promptIdElement.textContent;
                deletePrompt(promptId);
            });
        }
        
        // Delete directory confirmation
        const confirmDeleteDirBtn = document.getElementById('confirm-delete-directory-btn');
        if (confirmDeleteDirBtn) {
            confirmDeleteDirBtn.addEventListener('click', function() {
                const directoryPath = document.getElementById('delete-directory-path').textContent;
                deleteDirectory(directoryPath);
            });
        }
        
        // Blacklist functionality removed
        
        // Type filter buttons
        document.querySelectorAll('[data-type]').forEach(item => {
            item.addEventListener('click', function(e) {
                e.preventDefault();
                currentFilter.type = this.dataset.type;
                filterPrompts();
            });
        });
    });
    
    // Function to update the sort header icons and classes for prompts table
    function updateSortHeaders() {
        // Get the prompts table (first table that's not the directories table)
        const promptsTableBody = document.getElementById('prompts-table-body');
        if (!promptsTableBody) return;
        
        const promptsTable = promptsTableBody.closest('table');
        if (!promptsTable) return;
        
        // Remove all sort classes from prompts table
        promptsTable.querySelectorAll('.sortable').forEach(header => {
            header.classList.remove('sort-active', 'sort-asc', 'sort-desc');
        });
        
        // Find the active header and update its classes
        const activeHeader = promptsTable.querySelector(`.sortable[data-sort="${currentSort.column}"]`);
        if (activeHeader) {
            activeHeader.classList.add('sort-active');
            activeHeader.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
            
            // Update the icon class
            const icon = activeHeader.querySelector('.sort-icon');
            if (icon) {
                icon.classList.remove('bi-sort-alpha-down', 'bi-sort-alpha-up');
                icon.classList.add(currentSort.direction === 'asc' ? 'bi-sort-alpha-down' : 'bi-sort-alpha-up');
            }
        }
    }
    
    // Function to update the sort header icons and classes for directories table
    function updateDirectorySortHeaders() {
        // Remove all sort classes from directories table
        document.querySelectorAll('#directories-table .sortable').forEach(header => {
            header.classList.remove('sort-active', 'sort-asc', 'sort-desc');
        });
        
        // Find the active header and update its classes
        const activeHeader = document.querySelector(`#directories-table .sortable[data-sort="${currentDirectorySort.column}"]`);
        if (activeHeader) {
            activeHeader.classList.add('sort-active');
            activeHeader.classList.add(currentDirectorySort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
            
            // Update the icon class
            const icon = activeHeader.querySelector('.sort-icon');
            if (icon) {
                icon.classList.remove('bi-sort-alpha-down', 'bi-sort-alpha-up');
                icon.classList.add(currentDirectorySort.direction === 'asc' ? 'bi-sort-alpha-down' : 'bi-sort-alpha-up');
            }
        }
    }
    
    // Updated with more aggressive loading approach
    function loadPrompts() {
        // console.log('[DEBUG] loadPrompts: Function called.'); // Removed
        const tableBody = document.getElementById('prompts-table-body');
        
        // Show loading indicator
        tableBody.innerHTML = `
            <tr>
                <td colspan="6" class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mb-0 mt-2">Loading prompts...</p>
                </td>
            </tr>
        `;
        
        return new Promise((resolve, reject) => {
            // Directly fetch prompts with retry logic
                fetchPromptsWithRetry(resolve, reject);
        });
    }
    
    // Helper function to fetch prompts with retry logic
    function fetchPromptsWithRetry(resolve, reject, retries = 5) {
        // console.log('[DEBUG] fetchPromptsWithRetry: Function called.'); // Removed
        const tableBody = document.getElementById('prompts-table-body');
        
        // console.log(`Fetching prompts (${retries} retries left)`); // Kept original log
        
        // console.log('[DEBUG] fetchPromptsWithRetry: About to fetch /api/prompts/all'); // Removed
        fetch('/api/prompts/all')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to load prompts: ${response.status} ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Loaded prompts:', data);
                if (!Array.isArray(data)) {
                    throw new Error('Expected an array of prompts from API');
                }
                
                if (data.length === 0 && retries > 0) {
                    // No prompts found but we have retries left - try again
                    console.log('No prompts found but retries remaining - trying again');
                    setTimeout(() => fetchPromptsWithRetry(resolve, reject, retries - 1), 800);
                    return;
                }
                
                allPrompts = data;
                updatePromptsTable();
                updateTagFilters();
                resolve(data); // Resolve the promise with the loaded data
            })
            .catch(error => {
                console.error('Error loading prompts:', error);
                
                if (retries > 0) {
                    console.log(`Retrying prompt load (${retries} attempts left)...`);
                    setTimeout(() => fetchPromptsWithRetry(resolve, reject, retries - 1), 800);
                } else {
                    tableBody.innerHTML = `
                        <tr>
                            <td colspan="6" class="text-center py-4 text-danger">
                                <i class="bi bi-exclamation-circle fs-4"></i>
                                <p class="mb-0 mt-2">Error loading prompts: ${error.message}</p>
                                <p class="small">Try clicking the Refresh All button above.</p>
                            </td>
                        </tr>
                    `;
                    // Add a refresh button directly in the error message
                    const refreshBtn = document.createElement('button');
                    refreshBtn.className = 'btn btn-primary mt-2';
                    refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise me-1"></i> Refresh Now';
                    refreshBtn.addEventListener('click', function() {
                        refreshAllDirectories();
                    });
                    
                    const msgRow = tableBody.querySelector('tr');
                    msgRow.querySelector('td').appendChild(refreshBtn);
                    
                    reject(error); // Reject the promise with the error
                }
            });
    }
    
    function updatePromptsTable() {
        const tableBody = document.getElementById('prompts-table-body');
        
        try {
            if (!Array.isArray(allPrompts)) {
                throw new Error('Prompts data is not an array');
            }
            
            // Filter prompts based on current filters
            let filteredPrompts = allPrompts;
            
            if (currentFilter.type !== 'all') {
                // Filter based on composite status instead of prompt_type
                if (currentFilter.type === 'composite') {
                    filteredPrompts = filteredPrompts.filter(prompt => 
                        prompt.content && prompt.content.includes('[[') && prompt.content.includes(']]')
                    );
                } else if (currentFilter.type === 'standard') {
                    filteredPrompts = filteredPrompts.filter(prompt => 
                        !(prompt.content && prompt.content.includes('[[') && prompt.content.includes(']]'))
                    );
                }
                // Skip other type filters since we no longer have system/user types
            }
            
            if (currentFilter.tag !== 'all') {
                filteredPrompts = filteredPrompts.filter(prompt => 
                    prompt.tags && prompt.tags.includes(currentFilter.tag)
                );
            }
            
            if (currentFilter.search) {
                const searchLower = currentFilter.search.toLowerCase();
                filteredPrompts = filteredPrompts.filter(prompt => 
                    prompt.id.toLowerCase().includes(searchLower) ||
                    (prompt.name && prompt.name.toLowerCase().includes(searchLower)) ||
                    (prompt.display_name && prompt.display_name.toLowerCase().includes(searchLower)) ||
                    (prompt.description && prompt.description.toLowerCase().includes(searchLower)) ||
                    (prompt.directory && prompt.directory.toLowerCase().includes(searchLower)) ||
                    (prompt.directory_name && prompt.directory_name.toLowerCase().includes(searchLower))
                );
            }
            
            // Filter out prompts from disabled directories
            console.log('[updatePromptsTable] Global directories before filtering:', JSON.parse(JSON.stringify(directories)));
            const enabledDirectories = directories
                .filter(dir => dir.enabled)
                .map(dir => {
                    let path = dir.path;
                    if (path.endsWith('/')) {
                        path = path.slice(0, -1);
                    }
                    return path;
                });
            console.log('[updatePromptsTable] Normalized enabled directory paths:', enabledDirectories);
            
            filteredPrompts = filteredPrompts.filter(prompt => {
                const promptDir = prompt.directory;
                const isIncluded = enabledDirectories.includes(promptDir);
                if (!isIncluded) {
                    console.log(`[updatePromptsTable] Prompt '${prompt.id}' from directory '${promptDir}' is NOT IN enabled directories:`, enabledDirectories);
                }
                return isIncluded;
            });
            
            // Sort based on current sort settings using stableSort for a stable sort algorithm
            filteredPrompts = stableSort(filteredPrompts, (a, b) => {
                let aValue, bValue;
                
                // Get the values to compare based on the sort column
                switch (currentSort.column) {
                    case 'directory':
                        aValue = a.directory_name || a.directory || '';
                        bValue = b.directory_name || b.directory || '';
                        break;
                    case 'id':
                        // Sort by display name if available, fallback to name, then ID
                        aValue = a.display_name || a.name || a.id;
                        bValue = b.display_name || b.name || b.id;
                        break;
                    case 'description':
                        aValue = a.description || '';
                        bValue = b.description || '';
                        break;

                    case 'tags':
                        aValue = (a.tags && a.tags.length > 0) ? a.tags.join(',') : '';
                        bValue = (b.tags && b.tags.length > 0) ? b.tags.join(',') : '';
                        break;
                    case 'updated':
                        aValue = a.updated_at || '';
                        bValue = b.updated_at || '';
                        break;
                    default:
                        aValue = a.id;
                        bValue = b.id;
                }
                
                // Perform comparison based on the sort direction
                let result;
                if (currentSort.column === 'updated') {
                    // For dates, we need to use timestamp comparison
                    result = new Date(aValue) - new Date(bValue);
                } else {
                    // For strings, use localeCompare
                    result = String(aValue).localeCompare(String(bValue));
                }
                
                // Reverse the result if descending
                return currentSort.direction === 'desc' ? -result : result;
            });
            
            // Clear table
            tableBody.innerHTML = '';
            
            // Check if no prompts
            if (filteredPrompts.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="6" class="text-center py-4">
                            <p class="mb-0">No prompts found.</p>
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Add prompts to table
            filteredPrompts.forEach(prompt => {
                const row = document.createElement('tr');
                row.dataset.promptId = prompt.unique_id; // Add dataset for unique_id
                row.classList.add('prompt-row');         // Add class for easy selection
                
                // Directory cell - use directory_name for better UX
                const dirCell = document.createElement('td');
                dirCell.textContent = prompt.directory_name || prompt.directory || '';
                dirCell.title = prompt.directory || ''; // Full path in tooltip
                
                // Name cell - use display name for better UX
                const nameCell = document.createElement('td');
                const nameLink = document.createElement('a');
                // Use the ID for the URL but show the display name
                nameLink.href = `/prompts/${encodeURIComponent(prompt.id)}`;
                nameLink.textContent = prompt.display_name || prompt.name || prompt.id; // Show display name if available
                // Add a title showing the full ID for clarity
                nameLink.title = `${prompt.display_name || prompt.name || prompt.id} (Full ID: ${prompt.id})`;
                nameCell.appendChild(nameLink);
                
                // Description cell
                const descCell = document.createElement('td');
                descCell.textContent = prompt.description || '';
                
                // Tags cell
                const tagsCell = document.createElement('td');
                if (prompt.tags && prompt.tags.length > 0) {
                    prompt.tags.forEach(tag => {
                        const tagBadge = document.createElement('span');
                        tagBadge.className = 'badge bg-secondary me-1';
                        tagBadge.textContent = tag;
                        tagsCell.appendChild(tagBadge);
                    });
                } else {
                    tagsCell.textContent = '-';
                }
                
                // Updated cell
                const updatedCell = document.createElement('td');
                try {
                    updatedCell.textContent = dayjs(prompt.updated_at).fromNow();
                } catch (error) {
                    console.warn('Error formatting date:', error);
                    updatedCell.textContent = prompt.updated_at || 'Unknown';
                }
                
                // Actions cell
                const actionsCell = document.createElement('td');
                
                // Edit button
                const editBtn = document.createElement('a');
                editBtn.href = `/prompts/${prompt.id}`;
                editBtn.className = 'btn btn-sm btn-outline-primary me-1';
                editBtn.innerHTML = '<i class="bi bi-pencil"></i>';
                editBtn.title = 'Edit';
                
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-sm btn-outline-danger';
                deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
                deleteBtn.title = 'Delete';
                // Use the full ID for deletion
                const deleteId = prompt.id;
                deleteBtn.dataset.promptId = deleteId;
                deleteBtn.dataset.promptName = prompt.display_name || prompt.name || prompt.id; // For display purposes
                deleteBtn.addEventListener('click', function() {
                    showDeleteConfirmation(deleteId, prompt.display_name || prompt.name || prompt.id);
                });
                
                actionsCell.appendChild(editBtn);
                actionsCell.appendChild(deleteBtn);
                
                // Add cells to row
                row.appendChild(dirCell);
                row.appendChild(nameCell);
                row.appendChild(descCell);
                row.appendChild(tagsCell);
                row.appendChild(updatedCell);
                row.appendChild(actionsCell);
                
                tableBody.appendChild(row);
            });
            
            // ... inside updatePromptsTable, after filtering and before rendering ...
            const promptsCountSpan = document.getElementById('prompts-count');
            if (promptsCountSpan) {
                const denominator = typeof window.totalPromptCount === 'number' ? window.totalPromptCount : allPrompts.length;
                promptsCountSpan.textContent = `(${filteredPrompts.length}/${denominator})`;
            }
        } catch (error) {
            console.error('Error updating prompts table:', error);
            tableBody.innerHTML = `
                <tr>
                    <td colspan="6" class="text-center py-4 text-danger">
                        <i class="bi bi-exclamation-circle fs-4"></i>
                        <p class="mb-0 mt-2">Error displaying prompts: ${error.message}</p>
                    </td>
                </tr>
            `;
        }
    }
    
    // Updated to return a Promise for better initialization handling
    function loadDirectories() {
        // console.log('[DEBUG] loadDirectories: Function called.'); // Removed
        const tableBody = document.getElementById('directories-table-body');
        
        // Show loading indicator
        tableBody.innerHTML = `
            <tr>
                <td colspan="5" class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mb-0 mt-2">Loading directories...</p>
                </td>
            </tr>
        `;
        
        return new Promise((resolve, reject) => {
            // console.log('[DEBUG] loadDirectories: About to fetch /api/prompts/directories/all'); // Removed
            fetch('/api/prompts/directories/all')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to load directories: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    directories = data;
                    
                    // Use the updateDirectoriesUI function to display the directories
                    return updateDirectoriesUI().then(() => {
                        // After successfully loading directories, trigger a prompts reload
                        // to ensure prompts table is populated
                        if (directories.length > 0 && allPrompts.length === 0) {
                            console.log("Found directories but no prompts - initiating automatic prompts reload");
                            return loadPrompts()
                                .then(() => console.log("Successfully reloaded prompts after directory load"))
                                .catch(err => console.warn("Failed to reload prompts after directory load:", err));
                        }
                    });
                })
                .then(() => {
                    resolve(directories);
                })
                .catch(error => {
                    console.error('Error loading directories:', error);
                    tableBody.innerHTML = `
                        <tr>
                            <td colspan="5" class="text-center py-4 text-danger">
                                <i class="bi bi-exclamation-circle fs-4"></i>
                                <p class="mb-0 mt-2">Error loading directories. Please try again.</p>
                            </td>
                        </tr>
                    `;
                    reject(error);
                });
        });
    }
    
    function populateDirectorySelect(selectId) {
        const selectElement = document.getElementById(selectId);
        if (selectElement) {
            selectElement.innerHTML = '';
            directories.forEach(dir => {
                if (dir.enabled) {
                    const option = document.createElement('option');
                    option.value = dir.path;
                    option.textContent = dir.name;
                    selectElement.appendChild(option);
                }
            });
        }
    }
    
    function updateTagFilters() {
        const tagFiltersContainer = document.getElementById('tag-filters');
        
        // Collect all unique tags
        const tags = new Set();
        allPrompts.forEach(prompt => {
            if (prompt.tags) {
                prompt.tags.forEach(tag => tags.add(tag));
            }
        });
        
        // Clear container
        tagFiltersContainer.innerHTML = '';
        
        // Create filter items
        Array.from(tags).sort().forEach(tag => {
            const item = document.createElement('li');
            const link = document.createElement('a');
            link.className = 'dropdown-item';
            link.href = '#';
            link.dataset.tag = tag;
            link.textContent = tag;
            
            link.addEventListener('click', function(e) {
                e.preventDefault();
                currentFilter.tag = tag;
                filterPrompts();
            });
            
            item.appendChild(link);
            tagFiltersContainer.appendChild(item);
        });
        
        // Add event listener to "All Tags" option
        const allTagsOption = document.querySelector('[data-tag="all"]');
        if (allTagsOption) {
            allTagsOption.addEventListener('click', function(e) {
                e.preventDefault();
                currentFilter.tag = 'all';
                filterPrompts();
            });
        }
    }
    
    function filterPrompts() {
        updatePromptsTable();
        
        // After updating table, select the first prompt if search is active
        if (currentFilter.search) {
            const rows = document.querySelectorAll('#prompts-table-body tr');
            if (rows && rows.length > 0) {
                updateRowSelection(rows, 0);
            }
        }
    }

    // Function to handle toggling directory status
    function handleToggleDirectoryStatus(directoryPath, currentStatus) {
        // Save the current scroll position
        const scrollPosition = window.scrollY;
        
        // Show loading toast
        showToast('Updating directory status...', 'info');
        
        // Use the imported function from directory_manager.js
        toggleDirectoryStatus(directoryPath, currentStatus)
            .then(data => {
                // Update directory status in local state
                const dirIndex = directories.findIndex(dir => dir.path === directoryPath);
                if (dirIndex !== -1) {
                    directories[dirIndex].enabled = data.enabled;
                }
                
                // Get a reference to the directories section for scrolling back
                const directoriesCard = document.querySelector('.row:nth-child(2) .card');
                
                // Update prompts and directories without page reload
                Promise.all([
                    // Only update UI, don't reload the page
                    updatePromptsWithFilteredData(),
                    updateDirectoriesUI()
                ]).then(() => {
                    // Restore scroll position
                    window.scrollTo({
                        top: scrollPosition,
                        behavior: 'auto' // Use 'auto' to prevent animation
                    });
                    
                    showToast(`Directory ${data.enabled ? 'enabled' : 'disabled'} successfully`, 'success');
                });
            })
            .catch(error => {
                console.error('Error toggling directory status:', error);
                showToast(`Error toggling directory status: ${error.message}`, 'danger');
                
                // Restore scroll position even on error
                window.scrollTo({
                    top: scrollPosition,
                    behavior: 'auto'
                });
            });
    }
    
    // Function to update the prompts table without reloading all data
    function updatePromptsWithFilteredData() {
        return new Promise((resolve) => {
            // Filter existing prompts based on enabled directories
            const enabledDirectories = directories
                .filter(dir => dir.enabled)
                .map(dir => dir.path);
            
            // Filter and update the prompts table
            updatePromptsTable();
            resolve();
        });
    }
    
    // Function to update the directories UI without reloading all data
    function updateDirectoriesUI() {
        return new Promise((resolve) => {
            const tableBody = document.getElementById('directories-table-body');
            
            // Clear the table
            tableBody.innerHTML = '';
            
            // Sort directories based on current sort settings
            const sortedDirectories = stableSort([...directories], (a, b) => {
                let aValue, bValue;
                
                // Get the values to compare based on the sort column
                switch (currentDirectorySort.column) {
                    case 'name':
                        aValue = a.name || '';
                        bValue = b.name || '';
                        break;
                    case 'status':
                        aValue = a.enabled ? 'enabled' : 'disabled';
                        bValue = b.enabled ? 'enabled' : 'disabled';
                        break;
                    case 'path':
                        aValue = a.path || '';
                        bValue = b.path || '';
                        break;
                    case 'description':
                        aValue = a.description || '';
                        bValue = b.description || '';
                        break;
                    default:
                        aValue = a.name || '';
                        bValue = b.name || '';
                }
                
                // Perform string comparison
                const result = String(aValue).localeCompare(String(bValue));
                
                // Reverse the result if descending
                return currentDirectorySort.direction === 'desc' ? -result : result;
            });
            
            // Repopulate with sorted data
            sortedDirectories.forEach(dir => {
                const row = document.createElement('tr');
                
                // Name cell
                const nameCell = document.createElement('td');
                nameCell.textContent = dir.name;
                
                // Status cell with toggle
                const statusCell = document.createElement('td');
                const statusBadge = document.createElement('span');
                statusBadge.className = `badge status-badge ${dir.enabled ? 'bg-success' : 'bg-danger'}`;
                statusBadge.textContent = dir.enabled ? 'Enabled' : 'Disabled';
                statusBadge.dataset.path = dir.path;
                statusBadge.dataset.enabled = dir.enabled;
                statusBadge.title = dir.enabled ? 'Click to disable' : 'Click to enable';
                statusBadge.addEventListener('click', function() {
                    handleToggleDirectoryStatus(dir.path, dir.enabled);
                });
                statusCell.appendChild(statusBadge);
                
                // Path cell
                const pathCell = document.createElement('td');
                pathCell.textContent = dir.path;
                
                // Description cell
                const descCell = document.createElement('td');
                descCell.textContent = dir.description || '';
                
                // Actions cell
                const actionsCell = document.createElement('td');
                
                // Edit button
                const editBtn = document.createElement('button');
                editBtn.className = 'btn btn-sm btn-outline-primary me-1';
                editBtn.innerHTML = '<i class="bi bi-pencil"></i>';
                editBtn.title = 'Edit';
                editBtn.addEventListener('click', function() {
                    showEditDirectoryModal(dir);
                });
                
                // Refresh button
                const refreshBtn = document.createElement('button');
                refreshBtn.className = 'btn btn-sm btn-outline-secondary me-1';
                refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i>';
                refreshBtn.title = 'Refresh';
                refreshBtn.addEventListener('click', function() {
                    // Reload prompts from this directory
                    refreshDirectory(dir.path);
                });
                
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-sm btn-outline-danger';
                deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
                deleteBtn.title = 'Remove';
                deleteBtn.dataset.directoryPath = dir.path;
                deleteBtn.addEventListener('click', function() {
                    showDeleteDirectoryConfirmation(dir.path);
                });
                
                actionsCell.appendChild(editBtn);
                actionsCell.appendChild(refreshBtn);
                actionsCell.appendChild(deleteBtn);
                
                // Add cells to row
                row.appendChild(nameCell);
                row.appendChild(statusCell);
                row.appendChild(pathCell);
                row.appendChild(descCell);
                row.appendChild(actionsCell);
                
                tableBody.appendChild(row);
            });
            
            // Update directory select in the New Prompt modal
            populateDirectorySelect('promptDirectory');
            
            // Populate new prompt modal directories
            if (newPromptModal) {
                newPromptModal.populateDirectorySelect(directories);
            }
            
            // Update directory sort headers
            updateDirectorySortHeaders();
            
            // ... inside updateDirectoriesUI, after rendering all rows ...
            const directoriesCountSpan = document.getElementById('directories-count');
            if (directoriesCountSpan) {
                const enabledCount = directories.filter(dir => dir.enabled).length;
                directoriesCountSpan.textContent = `(${enabledCount}/${directories.length})`;
            }
            
            resolve();
        });
    }
    
    // Function to show the edit directory modal
    function showEditDirectoryModal(directory) {
        document.getElementById('editDirectoryPath').value = directory.path;
        document.getElementById('displayDirectoryPath').textContent = directory.path;
        document.getElementById('editDirectoryName').value = directory.name;
        document.getElementById('editDirectoryDescription').value = directory.description || '';
        
        // Show the modal
        const modal = new bootstrap.Modal(document.getElementById('editDirectoryModal'));
        modal.show();
    }
    
    // Function to update directory
    function handleUpdateDirectoryForm() {
        const path = document.getElementById('editDirectoryPath').value;
        const name = document.getElementById('editDirectoryName').value.trim();
        const description = document.getElementById('editDirectoryDescription').value.trim();
        
        // Validate
        if (!name) {
            alert('Directory name is required');
            return;
        }
        
        // Create directory data
        const directoryData = {
            name: name,
            description: description
        };
        
        // Show loading toast
        showToast('Updating directory...', 'info');
        
        // Use the imported function from directory_manager.js (should now be the global one)
        updateDirectory(path, directoryData)
            .then(data => {
                // Update directory in local state
                const dirIndex = directories.findIndex(dir => dir.path === path);
                if (dirIndex !== -1) {
                    directories[dirIndex].name = data.name;
                    directories[dirIndex].description = data.description;
                }
                
                // Refresh the directory list
                loadDirectories();
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('editDirectoryModal'));
                modal.hide();
                
                showToast('Directory updated successfully', 'success');
            })
            .catch(error => {
                console.error('Error updating directory:', error);
                showToast(`Error updating directory: ${error.message}`, 'danger');
            });
    }
    

    
    function addDirectory() {
        const path = document.getElementById('directoryPath').value.trim();
        const name = document.getElementById('directoryName').value.trim();
        const description = document.getElementById('directoryDescription').value.trim();
        
        // Validate
        if (!path) {
            alert('Directory path is required');
            return;
        }
        
        // Create directory data
        const directoryData = {
            path: path,
            name: name || undefined,
            description: description || undefined
        };
        
        // Send POST request
        fetch('/api/prompts/directories', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(directoryData)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to add directory');
            }
            return response.json();
        })
        .then(data => {
            // Success - reload directories and show toast
            loadDirectories();
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('addDirectoryModal'));
            modal.hide();
            
            // Clear form
            document.getElementById('directoryPath').value = '';
            document.getElementById('directoryName').value = '';
            document.getElementById('directoryDescription').value = '';
            
            // Show toast
            showToast('Directory added successfully');
        })
        .catch(error => {
            console.error('Error adding directory:', error);
            alert('Error adding directory: ' + error.message);
        });
    }
    
    function showDeleteConfirmation(promptId, displayName) {
        // Store the actual ID to delete (which might be the unique ID)
        document.getElementById('delete-prompt-id').dataset.id = promptId;
        // Show the human-readable name to the user
        document.getElementById('delete-prompt-id').textContent = displayName || promptId;
        const deleteModal = new bootstrap.Modal(document.getElementById('deletePromptModal'));
        deleteModal.show();
    }
    
    function showDeleteDirectoryConfirmation(directoryPath) {
        document.getElementById('delete-directory-path').textContent = directoryPath;
        const deleteModal = new bootstrap.Modal(document.getElementById('deleteDirectoryModal'));
        deleteModal.show();
    }
    
    function deletePrompt(promptId) {
        // Send DELETE request
        fetch(`/api/prompts/${encodeURIComponent(promptId)}`, {
            method: 'DELETE'
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to delete prompt');
            }
            return response.json();
        })
        .then(data => {
            // Success - reload prompts and show toast
            loadPrompts();
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('deletePromptModal'));
            modal.hide();
            
            // Show toast
            showToast('Prompt deleted successfully');
        })
        .catch(error => {
            console.error('Error deleting prompt:', error);
            alert('Error deleting prompt: ' + error.message);
        });
    }
    
    function deleteDirectory(directoryPath) {
        // Send DELETE request
        fetch(`/api/prompts/directories/${encodeURIComponent(directoryPath)}`, {
            method: 'DELETE'
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to remove directory');
            }
            return response.json();
        })
        .then(data => {
            // Success - reload directories and show toast
            loadDirectories();
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('deleteDirectoryModal'));
            modal.hide();
            
            // Show toast
            showToast('Directory removed successfully');
        })
        .catch(error => {
            console.error('Error removing directory:', error);
            alert('Error removing directory: ' + error.message);
        });
    }
    
    // Blacklist directory function removed
    
    // Function to update the row selection
    function updateRowSelection(rows, selectedIndex) {
        // Remove selection from all rows
        rows.forEach(row => row.classList.remove('selected'));
        
        // Add selection to the target row
        if (selectedIndex >= 0 && selectedIndex < rows.length) {
            rows[selectedIndex].classList.add('selected');
            
            // Scroll the row into view if needed
            rows[selectedIndex].scrollIntoView({
                behavior: 'smooth',
                block: 'nearest'
            });
            
            // Keep search box focused if it was focused before
            const searchBox = document.getElementById('prompt-search');
            if (document.activeElement === searchBox) {
                // Maintain focus on search box after selection
                setTimeout(() => searchBox.focus(), 10);
            }
        }
    }
</script>
{% endblock %}
json' },
                            body: JSON.stringify({ partial_path: partialPath })
                        });
                        if (!response.ok) {
                            const errorData = await response.json();
                            showToast(`Path completion failed: ${errorData.detail || response.statusText}`, 'danger');
                            if (suggestionsListElement) suggestionsListElement.style.display = 'none';
                            return;
                        }
                        const data = await response.json();
                        this.value = data.completed_path; 
                        displayPathSuggestions(data.suggestions, this, data.completed_path);
                    } catch (error) {
                        showToast('Error fetching path completions.', 'danger');
                        if (suggestionsListElement) suggestionsListElement.style.display = 'none';
                    }
                    return; // Stop after handling Tab
                }

                // Suggestion list navigation (only if list is visible)
                if (suggestionsListElement && suggestionsListElement.style.display === 'block') {
                    if (event.key === 'ArrowDown') {
                        event.preventDefault();
                        if (activeSuggestionIndex < suggestionsListElement.children.length - 1) {
                            activeSuggestionIndex++;
                            updateSuggestionHighlight();
                        }
                        return;
                    }
                    if (event.key === 'ArrowUp') {
                        event.preventDefault();
                        if (activeSuggestionIndex > 0) {
                            activeSuggestionIndex--;
                            updateSuggestionHighlight();
                        }
                        return;
                    }
                    if (event.key === 'Enter' && activeSuggestionIndex > -1) {
                        event.preventDefault();
                        suggestionsListElement.children[activeSuggestionIndex].dispatchEvent(new Event('mousedown'));
                        return;
                    }
                }

                // Escape: Close suggestion list if open
                if (event.key === 'Escape') {
                    if (suggestionsListElement && suggestionsListElement.style.display === 'block') {
                        event.preventDefault();
                        suggestionsListElement.style.display = 'none';
                        activeSuggestionIndex = -1; // Reset index
                        // Do not return here, allow Escape to bubble if suggestions were not open for modal closure
                    }
                }
            });

            directoryNameInput.addEventListener('keydown', function(event) {
                // Alt+T: Navigate fields
                if (event.altKey && event.key.toLowerCase() === 't') {
                    event.preventDefault();
                    if (event.shiftKey) { // Alt+Shift+T to go to previous (Path)
                        directoryPathInput.focus();
                    } else { // Alt+T to go to next (Description)
                        directoryDescriptionInput.focus();
                    }
                }
            });

            directoryDescriptionInput.addEventListener('keydown', function(event) {
                // Alt+T: Navigate fields
                if (event.altKey && event.key.toLowerCase() === 't') {
                    event.preventDefault();
                    if (event.shiftKey) { // Alt+Shift+T to go to previous (Name)
                        directoryNameInput.focus();
                    } else { // Alt+T to go to first (Path)
                        directoryPathInput.focus(); 
                    }
                }
            });

            // Modal-wide shortcuts for Ctrl+Enter and Ctrl+Esc
            if (addDirectoryModalElement) {
                addDirectoryModalElement.addEventListener('keydown', function(event) {
                    if (event.ctrlKey && event.key === 'Enter') {
                        event.preventDefault();
                        addDirectoryBtn.click(); // Simulate click on Add button
                    } else if (event.ctrlKey && event.key === 'Escape') {
                        event.preventDefault();
                        // Find the cancel button and click it
                        const cancelBtn = addDirectoryModalElement.querySelector('.modal-footer button[data-bs-dismiss="modal"]');
                        if (cancelBtn) {
                            cancelBtn.click();
                        }
                    }
                });
            }

            directoryPathInput.addEventListener('blur', function() {
                // Delay hiding to allow click on suggestion to register
                setTimeout(() => {
                    if (suggestionsListElement && suggestionsListElement.style.display === 'block' && !suggestionsListElement.matches(':hover')) {
                         suggestionsListElement.style.display = 'none';
                    }
                }, 150);
            });
            
            function updateSuggestionHighlight() {
                for (let i = 0; i < suggestionsListElement.children.length; i++) {
                    suggestionsListElement.children[i].classList.remove('selected-suggestion');
                }
                if (activeSuggestionIndex > -1) {
                    suggestionsListElement.children[activeSuggestionIndex].classList.add('selected-suggestion');
                    suggestionsListElement.children[activeSuggestionIndex].scrollIntoView({ block: 'nearest' });
                }
            }

            addDirectoryBtn.addEventListener('click', addDirectory);
        }
        
        // Edit directory form handler
        const updateDirectoryBtn = document.getElementById('updateDirectoryBtn');
        if (updateDirectoryBtn) {
            updateDirectoryBtn.addEventListener('click', handleUpdateDirectoryForm);
        }
        
        // Delete prompt confirmation
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
        if (confirmDeleteBtn) {
            confirmDeleteBtn.addEventListener('click', function() {
                const promptIdElement = document.getElementById('delete-prompt-id');
                // Use the stored ID attribute (which may be the unique ID) for deletion
                const promptId = promptIdElement.dataset.id || promptIdElement.textContent;
                deletePrompt(promptId);
            });
        }
        
        // Delete directory confirmation
        const confirmDeleteDirBtn = document.getElementById('confirm-delete-directory-btn');
        if (confirmDeleteDirBtn) {
            confirmDeleteDirBtn.addEventListener('click', function() {
                const directoryPath = document.getElementById('delete-directory-path').textContent;
                deleteDirectory(directoryPath);
            });
        }
        
        // Type filter buttons
        document.querySelectorAll('[data-type]').forEach(item => {
            item.addEventListener('click', function(e) {
                e.preventDefault();
                currentFilter.type = this.dataset.type;
                filterPrompts();
            });
        });
    });
    
    // Function to update the sort header icons and classes for prompts table
    function updateSortHeaders() {
        // Get the prompts table (first table that's not the directories table)
        const promptsTableBody = document.getElementById('prompts-table-body');
        if (!promptsTableBody) return;
        
        const promptsTable = promptsTableBody.closest('table');
        if (!promptsTable) return;
        
        // Remove all sort classes from prompts table
        promptsTable.querySelectorAll('.sortable').forEach(header => {
            header.classList.remove('sort-active', 'sort-asc', 'sort-desc');
        });
        
        // Find the active header and update its classes
        const activeHeader = promptsTable.querySelector(`.sortable[data-sort="${currentSort.column}"]`);
        if (activeHeader) {
            activeHeader.classList.add('sort-active');
            activeHeader.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
            
            // Update the icon class
            const icon = activeHeader.querySelector('.sort-icon');
            if (icon) {
                icon.classList.remove('bi-sort-alpha-down', 'bi-sort-alpha-up');
                icon.classList.add(currentSort.direction === 'asc' ? 'bi-sort-alpha-down' : 'bi-sort-alpha-up');
            }
        }
    }
    
    // Function to update the sort header icons and classes for directories table
    function updateDirectorySortHeaders() {
        // Remove all sort classes from directories table
        document.querySelectorAll('#directories-table .sortable').forEach(header => {
            header.classList.remove('sort-active', 'sort-asc', 'sort-desc');
        });
        
        // Find the active header and update its classes
        const activeHeader = document.querySelector(`#directories-table .sortable[data-sort="${currentDirectorySort.column}"]`);
        if (activeHeader) {
            activeHeader.classList.add('sort-active');
            activeHeader.classList.add(currentDirectorySort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
            
            // Update the icon class
            const icon = activeHeader.querySelector('.sort-icon');
            if (icon) {
                icon.classList.remove('bi-sort-alpha-down', 'bi-sort-alpha-up');
                icon.classList.add(currentDirectorySort.direction === 'asc' ? 'bi-sort-alpha-down' : 'bi-sort-alpha-up');
            }
        }
    }
    
    // Updated with more aggressive loading approach
    function loadPrompts() {
        const tableBody = document.getElementById('prompts-table-body');
        
        // Show loading indicator
        tableBody.innerHTML = `
            <tr>
                <td colspan="6" class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mb-0 mt-2">Loading prompts...</p>
                </td>
            </tr>
        `;
        
        return new Promise((resolve, reject) => {
            // Directly fetch prompts with retry logic
                fetchPromptsWithRetry(resolve, reject);
        });
    }
    
    // Helper function to fetch prompts with retry logic
    function fetchPromptsWithRetry(resolve, reject, retries = 5) {
        const tableBody = document.getElementById('prompts-table-body');
        
        console.log(`Fetching prompts (${retries} retries left)`);
        
        fetch('/api/prompts/all')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to load prompts: ${response.status} ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Loaded prompts:', data);
                if (!Array.isArray(data)) {
                    throw new Error('Expected an array of prompts from API');
                }
                
                if (data.length === 0 && retries > 0) {
                    // No prompts found but we have retries left - try again
                    console.log('No prompts found but retries remaining - trying again');
                    setTimeout(() => fetchPromptsWithRetry(resolve, reject, retries - 1), 800);
                    return;
                }
                
                allPrompts = data;
                updatePromptsTable();
                updateTagFilters();
                resolve(data); // Resolve the promise with the loaded data
            })
            .catch(error => {
                console.error('Error loading prompts:', error);
                
                if (retries > 0) {
                    console.log(`Retrying prompt load (${retries} attempts left)...`);
                    setTimeout(() => fetchPromptsWithRetry(resolve, reject, retries - 1), 800);
                } else {
                    tableBody.innerHTML = `
                        <tr>
                            <td colspan="6" class="text-center py-4 text-danger">
                                <i class="bi bi-exclamation-circle fs-4"></i>
                                <p class="mb-0 mt-2">Error loading prompts: ${error.message}</p>
                                <p class="small">Try clicking the Refresh All button above.</p>
                            </td>
                        </tr>
                    `;
                    // Add a refresh button directly in the error message
                    const refreshBtn = document.createElement('button');
                    refreshBtn.className = 'btn btn-primary mt-2';
                    refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise me-1"></i> Refresh Now';
                    refreshBtn.addEventListener('click', function() {
                        refreshAllDirectories();
                    });
                    
                    const msgRow = tableBody.querySelector('tr');
                    msgRow.querySelector('td').appendChild(refreshBtn);
                    
                    reject(error); // Reject the promise with the error
                }
            });
    }
    
    function updatePromptsTable() {
        const tableBody = document.getElementById('prompts-table-body');
        
        try {
            if (!Array.isArray(allPrompts)) {
                throw new Error('Prompts data is not an array');
            }
            
            // Filter prompts based on current filters
            let filteredPrompts = allPrompts;
            
            if (currentFilter.type !== 'all') {
                // Filter based on composite status instead of prompt_type
                if (currentFilter.type === 'composite') {
                    filteredPrompts = filteredPrompts.filter(prompt => 
                        prompt.content && prompt.content.includes('[[') && prompt.content.includes(']]')
                    );
                } else if (currentFilter.type === 'standard') {
                    filteredPrompts = filteredPrompts.filter(prompt => 
                        !(prompt.content && prompt.content.includes('[[') && prompt.content.includes(']]'))
                    );
                }
                // Skip other type filters since we no longer have system/user types
            }
            
            if (currentFilter.tag !== 'all') {
                filteredPrompts = filteredPrompts.filter(prompt => 
                    prompt.tags && prompt.tags.includes(currentFilter.tag)
                );
            }
            
            if (currentFilter.search) {
                const searchLower = currentFilter.search.toLowerCase();
                filteredPrompts = filteredPrompts.filter(prompt => 
                    prompt.id.toLowerCase().includes(searchLower) ||
                    (prompt.name && prompt.name.toLowerCase().includes(searchLower)) ||
                    (prompt.display_name && prompt.display_name.toLowerCase().includes(searchLower)) ||
                    (prompt.description && prompt.description.toLowerCase().includes(searchLower)) ||
                    (prompt.directory && prompt.directory.toLowerCase().includes(searchLower)) ||
                    (prompt.directory_name && prompt.directory_name.toLowerCase().includes(searchLower))
                );
            }
            
            // Filter out prompts from disabled directories
            const enabledDirectories = directories
                .filter(dir => dir.enabled)
                .map(dir => {
                    let path = dir.path;
                    if (path.endsWith('/')) {
                        path = path.slice(0, -1);
                    }
                    return path;
                });
            
            filteredPrompts = filteredPrompts.filter(prompt => {
                const promptDir = prompt.directory;
                const isIncluded = enabledDirectories.includes(promptDir);
                return isIncluded;
            });
            
            // Sort based on current sort settings using stableSort for a stable sort algorithm
            filteredPrompts = stableSort(filteredPrompts, (a, b) => {
                let aValue, bValue;
                
                // Get the values to compare based on the sort column
                switch (currentSort.column) {
                    case 'directory':
                        aValue = a.directory_name || a.directory || '';
                        bValue = b.directory_name || b.directory || '';
                        break;
                    case 'id':
                        // Sort by display name if available, fallback to name, then ID
                        aValue = a.display_name || a.name || a.id;
                        bValue = b.display_name || b.name || b.id;
                        break;
                    case 'description':
                        aValue = a.description || '';
                        bValue = b.description || '';
                        break;
                    case 'tags':
                        aValue = (a.tags && a.tags.length > 0) ? a.tags.join(',') : '';
                        bValue = (b.tags && b.tags.length > 0) ? b.tags.join(',') : '';
                        break;
                    case 'updated':
                        aValue = a.updated_at || '';
                        bValue = b.updated_at || '';
                        break;
                    default:
                        aValue = a.id;
                        bValue = b.id;
                }
                
                // Perform comparison based on the sort direction
                let result;
                if (currentSort.column === 'updated') {
                    // For dates, we need to use timestamp comparison
                    result = new Date(aValue) - new Date(bValue);
                } else {
                    // For strings, use localeCompare
                    result = String(aValue).localeCompare(String(bValue));
                }
                
                // Reverse the result if descending
                return currentSort.direction === 'desc' ? -result : result;
            });
            
            // Clear table
            tableBody.innerHTML = '';
            
            // Check if no prompts
            if (filteredPrompts.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="6" class="text-center py-4">
                            <p class="mb-0">No prompts found.</p>
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Add prompts to table
            filteredPrompts.forEach(prompt => {
                const row = document.createElement('tr');
                row.dataset.promptId = prompt.unique_id; // Add dataset for unique_id
                row.classList.add('prompt-row');         // Add class for easy selection
                
                // Directory cell - use directory_name for better UX
                const dirCell = document.createElement('td');
                dirCell.textContent = prompt.directory_name || prompt.directory || '';
                dirCell.title = prompt.directory || ''; // Full path in tooltip
                
                // Name cell - use display name for better UX
                const nameCell = document.createElement('td');
                const nameLink = document.createElement('a');
                // Use the ID for the URL but show the display name
                nameLink.href = `/prompts/${encodeURIComponent(prompt.id)}`;
                nameLink.textContent = prompt.display_name || prompt.name || prompt.id; // Show display name if available
                // Add a title showing the full ID for clarity
                nameLink.title = `${prompt.display_name || prompt.name || prompt.id} (Full ID: ${prompt.id})`;
                nameCell.appendChild(nameLink);
                
                // Description cell
                const descCell = document.createElement('td');
                descCell.textContent = prompt.description || '';
                
                // Tags cell
                const tagsCell = document.createElement('td');
                if (prompt.tags && prompt.tags.length > 0) {
                    prompt.tags.forEach(tag => {
                        const tagBadge = document.createElement('span');
                        tagBadge.className = 'badge bg-secondary me-1';
                        tagBadge.textContent = tag;
                        tagsCell.appendChild(tagBadge);
                    });
                } else {
                    tagsCell.textContent = '-';
                }
                
                // Updated cell
                const updatedCell = document.createElement('td');
                try {
                    updatedCell.textContent = dayjs(prompt.updated_at).fromNow();
                } catch (error) {
                    console.warn('Error formatting date:', error);
                    updatedCell.textContent = prompt.updated_at || 'Unknown';
                }
                
                // Actions cell
                const actionsCell = document.createElement('td');
                
                // Edit button
                const editBtn = document.createElement('a');
                editBtn.href = `/prompts/${prompt.id}`;
                editBtn.className = 'btn btn-sm btn-outline-primary me-1';
                editBtn.innerHTML = '<i class="bi bi-pencil"></i>';
                editBtn.title = 'Edit';
                
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-sm btn-outline-danger';
                deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
                deleteBtn.title = 'Delete';
                // Use the full ID for deletion
                const deleteId = prompt.id;
                deleteBtn.dataset.promptId = deleteId;
                deleteBtn.dataset.promptName = prompt.display_name || prompt.name || prompt.id; // For display purposes
                deleteBtn.addEventListener('click', function() {
                    showDeleteConfirmation(deleteId, prompt.display_name || prompt.name || prompt.id);
                });
                
                actionsCell.appendChild(editBtn);
                actionsCell.appendChild(deleteBtn);
                
                // Add cells to row
                row.appendChild(dirCell);
                row.appendChild(nameCell);
                row.appendChild(descCell);
                row.appendChild(tagsCell);
                row.appendChild(updatedCell);
                row.appendChild(actionsCell);
                
                tableBody.appendChild(row);
            });
            
            // Update counts
            const promptsCountSpan = document.getElementById('prompts-count');
            if (promptsCountSpan) {
                const denominator = typeof window.totalPromptCount === 'number' ? window.totalPromptCount : allPrompts.length;
                promptsCountSpan.textContent = `(${filteredPrompts.length}/${denominator})`;
            }
        } catch (error) {
            console.error('Error updating prompts table:', error);
            tableBody.innerHTML = `
                <tr>
                    <td colspan="6" class="text-center py-4 text-danger">
                        <i class="bi bi-exclamation-circle fs-4"></i>
                        <p class="mb-0 mt-2">Error displaying prompts: ${error.message}</p>
                    </td>
                </tr>
            `;
        }
    }
    
    // Updated to return a Promise for better initialization handling
    function loadDirectories() {
        const tableBody = document.getElementById('directories-table-body');
        
        // Show loading indicator
        tableBody.innerHTML = `
            <tr>
                <td colspan="5" class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mb-0 mt-2">Loading directories...</p>
                </td>
            </tr>
        `;
        
        return new Promise((resolve, reject) => {
            fetch('/api/prompts/directories/all')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to load directories: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    directories = data;
                    
                    // Use the updateDirectoriesUI function to display the directories
                    return updateDirectoriesUI().then(() => {
                        // After successfully loading directories, trigger a prompts reload
                        // to ensure prompts table is populated
                        if (directories.length > 0 && allPrompts.length === 0) {
                            console.log("Found directories but no prompts - initiating automatic prompts reload");
                            return loadPrompts()
                                .then(() => console.log("Successfully reloaded prompts after directory load"))
                                .catch(err => console.warn("Failed to reload prompts after directory load:", err));
                        }
                    });
                })
                .then(() => {
                    resolve(directories);
                })
                .catch(error => {
                    console.error('Error loading directories:', error);
                    tableBody.innerHTML = `
                        <tr>
                            <td colspan="5" class="text-center py-4 text-danger">
                                <i class="bi bi-exclamation-circle fs-4"></i>
                                <p class="mb-0 mt-2">Error loading directories. Please try again.</p>
                            </td>
                        </tr>
                    `;
                    reject(error);
                });
        });
    }
    
    function populateDirectorySelect(selectId) {
        const selectElement = document.getElementById(selectId);
        if (selectElement) {
            selectElement.innerHTML = '';
            directories.forEach(dir => {
                if (dir.enabled) {
                    const option = document.createElement('option');
                    option.value = dir.path;
                    option.textContent = dir.name;
                    selectElement.appendChild(option);
                }
            });
        }
    }
    
    function updateTagFilters() {
        const tagFiltersContainer = document.getElementById('tag-filters');
        
        // Collect all unique tags
        const tags = new Set();
        allPrompts.forEach(prompt => {
            if (prompt.tags) {
                prompt.tags.forEach(tag => tags.add(tag));
            }
        });
        
        // Clear container
        tagFiltersContainer.innerHTML = '';
        
        // Create filter items
        Array.from(tags).sort().forEach(tag => {
            const item = document.createElement('li');
            const link = document.createElement('a');
            link.className = 'dropdown-item';
            link.href = '#';
            link.dataset.tag = tag;
            link.textContent = tag;
            
            link.addEventListener('click', function(e) {
                e.preventDefault();
                currentFilter.tag = tag;
                filterPrompts();
            });
            
            item.appendChild(link);
            tagFiltersContainer.appendChild(item);
        });
        
        // Add event listener to "All Tags" option
        const allTagsOption = document.querySelector('[data-tag="all"]');
        if (allTagsOption) {
            allTagsOption.addEventListener('click', function(e) {
                e.preventDefault();
                currentFilter.tag = 'all';
                filterPrompts();
            });
        }
    }
    
    function filterPrompts() {
        updatePromptsTable();
        
        // After updating table, select the first prompt if search is active
        if (currentFilter.search) {
            const rows = document.querySelectorAll('#prompts-table-body tr');
            if (rows && rows.length > 0) {
                updateRowSelection(rows, 0);
            }
        }
    }

    // Function to handle toggling directory status
    function handleToggleDirectoryStatus(directoryPath, currentStatus) {
        // Save the current scroll position
        const scrollPosition = window.scrollY;
        
        // Show loading toast
        showToast('Updating directory status...', 'info');
        
        // Use the imported function from directory_manager.js
        toggleDirectoryStatus(directoryPath, currentStatus)
            .then(data => {
                // Update directory status in local state
                const dirIndex = directories.findIndex(dir => dir.path === directoryPath);
                if (dirIndex !== -1) {
                    directories[dirIndex].enabled = data.enabled;
                }
                
                // Update prompts and directories without page reload
                Promise.all([
                    // Only update UI, don't reload the page
                    updatePromptsWithFilteredData(),
                    updateDirectoriesUI()
                ]).then(() => {
                    // Restore scroll position
                    window.scrollTo({
                        top: scrollPosition,
                        behavior: 'auto' // Use 'auto' to prevent animation
                    });
                    
                    showToast(`Directory ${data.enabled ? 'enabled' : 'disabled'} successfully`, 'success');
                });
            })
            .catch(error => {
                console.error('Error toggling directory status:', error);
                showToast(`Error toggling directory status: ${error.message}`, 'danger');
                
                // Restore scroll position even on error
                window.scrollTo({
                    top: scrollPosition,
                    behavior: 'auto'
                });
            });
    }
    
    // Function to update the prompts table without reloading all data
    function updatePromptsWithFilteredData() {
        return new Promise((resolve) => {
            // Filter existing prompts based on enabled directories
            const enabledDirectories = directories
                .filter(dir => dir.enabled)
                .map(dir => dir.path);
            
            // Filter and update the prompts table
            updatePromptsTable();
            resolve();
        });
    }
    
    // Function to update the directories UI without reloading all data
    function updateDirectoriesUI() {
        return new Promise((resolve) => {
            const tableBody = document.getElementById('directories-table-body');
            
            // Clear the table
            tableBody.innerHTML = '';
            
            // Sort directories based on current sort settings
            const sortedDirectories = stableSort([...directories], (a, b) => {
                let aValue, bValue;
                
                // Get the values to compare based on the sort column
                switch (currentDirectorySort.column) {
                    case 'name':
                        aValue = a.name || '';
                        bValue = b.name || '';
                        break;
                    case 'status':
                        aValue = a.enabled ? 'enabled' : 'disabled';
                        bValue = b.enabled ? 'enabled' : 'disabled';
                        break;
                    case 'path':
                        aValue = a.path || '';
                        bValue = b.path || '';
                        break;
                    case 'description':
                        aValue = a.description || '';
                        bValue = b.description || '';
                        break;
                    default:
                        aValue = a.name || '';
                        bValue = b.name || '';
                }
                
                // Perform string comparison
                const result = String(aValue).localeCompare(String(bValue));
                
                // Reverse the result if descending
                return currentDirectorySort.direction === 'desc' ? -result : result;
            });
            
            // Repopulate with sorted data
            sortedDirectories.forEach(dir => {
                const row = document.createElement('tr');
                
                // Name cell
                const nameCell = document.createElement('td');
                nameCell.textContent = dir.name;
                
                // Status cell with toggle
                const statusCell = document.createElement('td');
                const statusBadge = document.createElement('span');
                statusBadge.className = `badge status-badge ${dir.enabled ? 'bg-success' : 'bg-danger'}`;
                statusBadge.textContent = dir.enabled ? 'Enabled' : 'Disabled';
                statusBadge.dataset.path = dir.path;
                statusBadge.dataset.enabled = dir.enabled;
                statusBadge.title = dir.enabled ? 'Click to disable' : 'Click to enable';
                statusBadge.addEventListener('click', function() {
                    handleToggleDirectoryStatus(dir.path, dir.enabled);
                });
                statusCell.appendChild(statusBadge);
                
                // Path cell
                const pathCell = document.createElement('td');
                pathCell.textContent = dir.path;
                
                // Description cell
                const descCell = document.createElement('td');
                descCell.textContent = dir.description || '';
                
                // Actions cell
                const actionsCell = document.createElement('td');
                
                // Edit button
                const editBtn = document.createElement('button');
                editBtn.className = 'btn btn-sm btn-outline-primary me-1';
                editBtn.innerHTML = '<i class="bi bi-pencil"></i>';
                editBtn.title = 'Edit';
                editBtn.addEventListener('click', function() {
                    showEditDirectoryModal(dir);
                });
                
                // Refresh button
                const refreshBtn = document.createElement('button');
                refreshBtn.className = 'btn btn-sm btn-outline-secondary me-1';
                refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i>';
                refreshBtn.title = 'Refresh';
                refreshBtn.addEventListener('click', function() {
                    // Reload prompts from this directory
                    refreshDirectory(dir.path);
                });
                
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-sm btn-outline-danger';
                deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
                deleteBtn.title = 'Remove';
                deleteBtn.dataset.directoryPath = dir.path;
                deleteBtn.addEventListener('click', function() {
                    showDeleteDirectoryConfirmation(dir.path);
                });
                
                actionsCell.appendChild(editBtn);
                actionsCell.appendChild(refreshBtn);
                actionsCell.appendChild(deleteBtn);
                
                // Add cells to row
                row.appendChild(nameCell);
                row.appendChild(statusCell);
                row.appendChild(pathCell);
                row.appendChild(descCell);
                row.appendChild(actionsCell);
                
                tableBody.appendChild(row);
            });
            
            // Update directory select in the New Prompt modal
            populateDirectorySelect('promptDirectory');
            
            // Populate new prompt modal directories
            if (newPromptModal) {
                newPromptModal.populateDirectorySelect(directories);
            }
            
            // Update directory sort headers
            updateDirectorySortHeaders();
            
            // Update counts
            const directoriesCountSpan = document.getElementById('directories-count');
            if (directoriesCountSpan) {
                const enabledCount = directories.filter(dir => dir.enabled).length;
                directoriesCountSpan.textContent = `(${enabledCount}/${directories.length})`;
            }
            
            resolve();
        });
    }
    
    // Function to show the edit directory modal
    function showEditDirectoryModal(directory) {
        document.getElementById('editDirectoryPath').value = directory.path;
        document.getElementById('displayDirectoryPath').textContent = directory.path;
        document.getElementById('editDirectoryName').value = directory.name;
        document.getElementById('editDirectoryDescription').value = directory.description || '';
        
        // Show the modal
        const modal = new bootstrap.Modal(document.getElementById('editDirectoryModal'));
        modal.show();
    }
    
    // Function to update directory
    function handleUpdateDirectoryForm() {
        const path = document.getElementById('editDirectoryPath').value;
        const name = document.getElementById('editDirectoryName').value.trim();
        const description = document.getElementById('editDirectoryDescription').value.trim();
        
        // Validate
        if (!name) {
            alert('Directory name is required');
            return;
        }
        
        // Create directory data
        const directoryData = {
            name: name,
            description: description
        };
        
        // Show loading toast
        showToast('Updating directory...', 'info');
        
        // Use the imported function from directory_manager.js (should now be the global one)
        updateDirectory(path, directoryData)
            .then(data => {
                // Update directory in local state
                const dirIndex = directories.findIndex(dir => dir.path === path);
                if (dirIndex !== -1) {
                    directories[dirIndex].name = data.name;
                    directories[dirIndex].description = data.description;
                }
                
                // Refresh the directory list
                loadDirectories();
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('editDirectoryModal'));
                modal.hide();
                
                showToast('Directory updated successfully', 'success');
            })
            .catch(error => {
                console.error('Error updating directory:', error);
                showToast(`Error updating directory: ${error.message}`, 'danger');
            });
    }
    
    function addDirectory() {
        const path = document.getElementById('directoryPath').value.trim();
        const name = document.getElementById('directoryName').value.trim();
        const description = document.getElementById('directoryDescription').value.trim();
        
        // Validate
        if (!path) {
            alert('Directory path is required');
            return;
        }
        
        // Create directory data
        const directoryData = {
            path: path,
            name: name || undefined,
            description: description || undefined
        };
        
        // Send POST request
        fetch('/api/prompts/directories', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(directoryData)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to add directory');
            }
            return response.json();
        })
        .then(data => {
            // Success - reload directories and show toast
            loadDirectories();
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('addDirectoryModal'));
            modal.hide();
            
            // Clear form
            document.getElementById('directoryPath').value = '';
            document.getElementById('directoryName').value = '';
            document.getElementById('directoryDescription').value = '';
            
            // Show toast
            showToast('Directory added successfully');
        })
        .catch(error => {
            console.error('Error adding directory:', error);
            alert('Error adding directory: ' + error.message);
        });
    }
    
    function showDeleteConfirmation(promptId, displayName) {
        // Store the actual ID to delete (which might be the unique ID)
        document.getElementById('delete-prompt-id').dataset.id = promptId;
        // Show the human-readable name to the user
        document.getElementById('delete-prompt-id').textContent = displayName || promptId;
        const deleteModal = new bootstrap.Modal(document.getElementById('deletePromptModal'));
        deleteModal.show();
    }
    
    function showDeleteDirectoryConfirmation(directoryPath) {
        document.getElementById('delete-directory-path').textContent = directoryPath;
        const deleteModal = new bootstrap.Modal(document.getElementById('deleteDirectoryModal'));
        deleteModal.show();
    }
    
    function deletePrompt(promptId) {
        // Send DELETE request
        fetch(`/api/prompts/${encodeURIComponent(promptId)}`, {
            method: 'DELETE'
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to delete prompt');
            }
            return response.json();
        })
        .then(data => {
            // Success - reload prompts and show toast
            loadPrompts();
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('deletePromptModal'));
            modal.hide();
            
            // Show toast
            showToast('Prompt deleted successfully');
        })
        .catch(error => {
            console.error('Error deleting prompt:', error);
            alert('Error deleting prompt: ' + error.message);
        });
    }
    
    function deleteDirectory(directoryPath) {
        // Send DELETE request
        fetch(`/api/prompts/directories/${encodeURIComponent(directoryPath)}`, {
            method: 'DELETE'
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to remove directory');
            }
            return response.json();
        })
        .then(data => {
            // Success - reload directories and show toast
            loadDirectories();
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('deleteDirectoryModal'));
            modal.hide();
            
            // Show toast
            showToast('Directory removed successfully');
        })
        .catch(error => {
            console.error('Error removing directory:', error);
            alert('Error removing directory: ' + error.message);
        });
    }
    
    // Function to update the row selection
    function updateRowSelection(rows, selectedIndex) {
        // Remove selection from all rows
        rows.forEach(row => row.classList.remove('selected'));
        
        // Add selection to the target row
        if (selectedIndex >= 0 && selectedIndex < rows.length) {
            rows[selectedIndex].classList.add('selected');
            
            // Scroll the row into view if needed
            rows[selectedIndex].scrollIntoView({
                behavior: 'smooth',
                block: 'nearest'
            });
            
            // Keep search box focused if it was focused before
            const searchBox = document.getElementById('prompt-search');
            if (document.activeElement === searchBox) {
                // Maintain focus on search box after selection
                setTimeout(() => searchBox.focus(), 10);
            }
        }
    }
</script>
{% endblock %}
